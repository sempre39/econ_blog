{
  
    
        "post0": {
            "title": "(12주차) 11월30일 + 11월25일보충강의",
            "content": "&#45936;&#51060;&#53552;&#54532;&#47112;&#51076;&#44284; &#54000;&#48660; . library(tidyverse) . - 길이가 50인 벡터생성 . A = rnorm(10*5) A ## 길이가 50인 벡터에 정규분포에 추출한 값 . [1] 1.17767702 2.73106894 -1.35304458 -0.03276446 0.53369832 0.49395437 [7] -0.57098744 0.08639052 0.13038589 -0.83919513 0.63070688 0.79315491 [13] -0.88411918 -0.89302478 -1.73600236 -1.03698473 -0.01582456 0.96717754 [19] -0.22076719 1.01093743 0.95756614 -1.06746861 -0.80694017 0.40289417 [25] 0.03584857 0.07879276 -1.20817133 -0.67848560 -0.99625585 0.99035758 [31] -0.30129979 0.63455394 0.59275899 -0.02683564 0.36659406 -0.39990796 [37] 0.03857880 -0.94117668 -0.52508619 0.68735157 -0.11328093 -0.62775891 [43] 0.90407099 0.45493649 -0.32498564 0.11173280 -0.18886705 -0.30540003 [49] 1.84845946 -0.17473138 . - 매트릭스로 변경 . dim(A) = c(10,5) A . [,1] [,2] [,3] [,4] [,5] [1,] 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 [2,] 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 [3,] -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 [4,] -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 [5,] 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 [6,] 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 [7,] -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 [8,] 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 [9,] 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 [10,] -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - 티블로 변경 (자동으로 V1,...,V5 열의 이름이 지정됨) . A = as_tibble(A) A . Warning message: “The `x` argument of `as_tibble.matrix()` must have unique column names if `.name_repair` is omitted as of tibble 2.0.0. Using compatibility `.name_repair`. This warning is displayed once every 8 hours. Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.” . V1 V2 V3 V4 V5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - 컬럼의 이름 확인 . colnames(A) . [1] &#34;V1&#34; &#34;V2&#34; &#34;V3&#34; &#34;V4&#34; &#34;V5&#34; . - 칼럼의 이름을 바꾸고 싶다면? . colnames(A) = c(&#39;X1&#39;,&#39;X2&#39;,&#39;X3&#39;,&#39;X4&#39;,&#39;X5&#39;) A . X1 X2 X3 X4 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . select() . - 처음 3개의 칼럼과 마지막 1개의 칼럼을 선택하고 싶다면? . A %&gt;% select(1:3,5) . X1 X2 X3 X5 1 1.17767702 0.63070688 0.95756614 -0.1132809 2 2.73106894 0.79315491 -1.06746861 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.9040710 4 -0.03276446 -0.89302478 0.40289417 0.4549365 5 0.53369832 -1.73600236 0.03584857 -0.3249856 6 0.49395437 -1.03698473 0.07879276 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 1.8484595 10 -0.83919513 1.01093743 0.99035758 -0.1747314 . - 열의 이름을 통하여서도 선택할 수 있음 . A %&gt;% select(X1:X3,X5) . X1 X2 X3 X5 1 1.17767702 0.63070688 0.95756614 -0.1132809 2 2.73106894 0.79315491 -1.06746861 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.9040710 4 -0.03276446 -0.89302478 0.40289417 0.4549365 5 0.53369832 -1.73600236 0.03584857 -0.3249856 6 0.49395437 -1.03698473 0.07879276 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 1.8484595 10 -0.83919513 1.01093743 0.99035758 -0.1747314 . - 열의 이름과 위치인덱스를 혼합하여 사용할 수 있음 . A %&gt;% select(X1:X3, 5) . X1 X2 X3 X5 1 1.17767702 0.63070688 0.95756614 -0.1132809 2 2.73106894 0.79315491 -1.06746861 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.9040710 4 -0.03276446 -0.89302478 0.40289417 0.4549365 5 0.53369832 -1.73600236 0.03584857 -0.3249856 6 0.49395437 -1.03698473 0.07879276 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 1.8484595 10 -0.83919513 1.01093743 0.99035758 -0.1747314 . - 열의 이름과 위치인덱스를 혼합하여 사용할 수 있음 (2) . A %&gt;% select(1:3, X5) . X1 X2 X3 X5 1 1.17767702 0.63070688 0.95756614 -0.1132809 2 2.73106894 0.79315491 -1.06746861 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.9040710 4 -0.03276446 -0.89302478 0.40289417 0.4549365 5 0.53369832 -1.73600236 0.03584857 -0.3249856 6 0.49395437 -1.03698473 0.07879276 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 1.8484595 10 -0.83919513 1.01093743 0.99035758 -0.1747314 . - 선택한 결과를 다른 변수에 저장가능 . A %&gt;% select(1:3, X5) -&gt; B B . X1 X2 X3 X5 1 1.17767702 0.63070688 0.95756614 -0.1132809 2 2.73106894 0.79315491 -1.06746861 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.9040710 4 -0.03276446 -0.89302478 0.40289417 0.4549365 5 0.53369832 -1.73600236 0.03584857 -0.3249856 6 0.49395437 -1.03698473 0.07879276 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 1.8484595 10 -0.83919513 1.01093743 0.99035758 -0.1747314 . select(-c()) . - A라는 자료를 다시 살펴보자. . A . X1 X2 X3 X4 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - 특정열을 제외하고 선택 . A %&gt;% select(-(X1:X3)) . X4 X5 1 -0.30129979 -0.1132809 2 0.63455394 -0.6277589 3 0.59275899 0.9040710 4 -0.02683564 0.4549365 5 0.36659406 -0.3249856 6 -0.39990796 0.1117328 7 0.03857880 -0.1888670 8 -0.94117668 -0.3054000 9 -0.52508619 1.8484595 10 0.68735157 -0.1747314 . A %&gt;% select(-(1:3)) . X4 X5 1 -0.30129979 -0.1132809 2 0.63455394 -0.6277589 3 0.59275899 0.9040710 4 -0.02683564 0.4549365 5 0.36659406 -0.3249856 6 -0.39990796 0.1117328 7 0.03857880 -0.1888670 8 -0.94117668 -0.3054000 9 -0.52508619 1.8484595 10 0.68735157 -0.1747314 . select(...,start_with()) . - 데이터 확인 . A . X1 X2 X3 X4 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - 열의 이름 확인 및 변경 . colnames(A) . [1] &#34;X1&#34; &#34;X2&#34; &#34;X3&#34; &#34;X4&#34; &#34;X5&#34; . colnames(A)= c(&#39;XY1&#39;,&#39;XY2&#39;,&#39;XZ1&#39;,&#39;XZ2&#39;,&#39;X5&#39;) . A . XY1 XY2 XZ1 XZ2 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - XY로 시작하는 열을 선택 . A %&gt;% select(starts_with(&#39;XY&#39;)) . XY1 XY2 1 1.17767702 0.63070688 2 2.73106894 0.79315491 3 -1.35304458 -0.88411918 4 -0.03276446 -0.89302478 5 0.53369832 -1.73600236 6 0.49395437 -1.03698473 7 -0.57098744 -0.01582456 8 0.08639052 0.96717754 9 0.13038589 -0.22076719 10 -0.83919513 1.01093743 . select(...,ends_with()) . - 데이터확인 . A . XY1 XY2 XZ1 XZ2 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - 2로 끝나는 열을 선택 . A %&gt;% select(ends_with(&#39;2&#39;)) . XY2 XZ2 1 0.63070688 -0.30129979 2 0.79315491 0.63455394 3 -0.88411918 0.59275899 4 -0.89302478 -0.02683564 5 -1.73600236 0.36659406 6 -1.03698473 -0.39990796 7 -0.01582456 0.03857880 8 0.96717754 -0.94117668 9 -0.22076719 -0.52508619 10 1.01093743 0.68735157 . select(...,contains()) . - 데이터확인 . A . XY1 XY2 XZ1 XZ2 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - Z를 포함하는 열을 선택 . A %&gt;% select(contains(&quot;Z&quot;)) . XZ1 XZ2 1 0.95756614 -0.30129979 2 -1.06746861 0.63455394 3 -0.80694017 0.59275899 4 0.40289417 -0.02683564 5 0.03584857 0.36659406 6 0.07879276 -0.39990796 7 -1.20817133 0.03857880 8 -0.67848560 -0.94117668 9 -0.99625585 -0.52508619 10 0.99035758 0.68735157 . select(...,everything()) . - 데이터확인 . A . XY1 XY2 XZ1 XZ2 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - Z를 포함하는 열을 앞으로 이동시킴 . A %&gt;% select(contains(&quot;Z&quot;),everything()) . XZ1 XZ2 XY1 XY2 X5 1 0.95756614 -0.30129979 1.17767702 0.63070688 -0.1132809 2 -1.06746861 0.63455394 2.73106894 0.79315491 -0.6277589 3 -0.80694017 0.59275899 -1.35304458 -0.88411918 0.9040710 4 0.40289417 -0.02683564 -0.03276446 -0.89302478 0.4549365 5 0.03584857 0.36659406 0.53369832 -1.73600236 -0.3249856 6 0.07879276 -0.39990796 0.49395437 -1.03698473 0.1117328 7 -1.20817133 0.03857880 -0.57098744 -0.01582456 -0.1888670 8 -0.67848560 -0.94117668 0.08639052 0.96717754 -0.3054000 9 -0.99625585 -0.52508619 0.13038589 -0.22076719 1.8484595 10 0.99035758 0.68735157 -0.83919513 1.01093743 -0.1747314 . filter() . - 데이터확인 . A . XY1 XY2 XZ1 XZ2 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - X5&gt;0인 행들만 뽑고싶다. . A %&gt;% filter(X5&gt;0) . XY1 XY2 XZ1 XZ2 X5 1 -1.35304458 -0.8841192 -0.80694017 0.59275899 0.9040710 2 -0.03276446 -0.8930248 0.40289417 -0.02683564 0.4549365 3 0.49395437 -1.0369847 0.07879276 -0.39990796 0.1117328 4 0.13038589 -0.2207672 -0.99625585 -0.52508619 1.8484595 . - X5&gt;0 이고 XY2&gt;0 인 행들만 뽑고싶다. . A %&gt;% filter(X5&gt;0 &amp; XY2&gt;0) . XY1 XY2 XZ1 XZ2 X5 . - 위의 결과에서 XZ를 포함하는 열을 뽑고싶다. . A %&gt;% filter(X5&gt;0 &amp; XY2&gt;0) %&gt;% select(contains(&quot;XZ&quot;)) . XZ1 XZ2 . mutate() . - 데이터를 확인 . A . XY1 XY2 XZ1 XZ2 X5 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 . - 새로운 변수추가 . A %&gt;% mutate(X6=abs(X5)) . XY1 XY2 XZ1 XZ2 X5 X6 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 0.1747314 . - 여러개의 새로운 변수를 추가하는 기능도 있음 . A %&gt;% mutate(X6=abs(X5),Z7=X5**2) . XY1 XY2 XZ1 XZ2 X5 X6 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 0.1747314 Z7 1 0.01283257 2 0.39408125 3 0.81734435 4 0.20696721 5 0.10561567 6 0.01248422 7 0.03567076 8 0.09326918 9 3.41680236 10 0.03053106 . - 표준화 . A %&gt;% mutate(X6=abs(X5),Z7=X5**2,Z8=(Z7-mean(Z7))/sd(Z7)) . XY1 XY2 XZ1 XZ2 X5 X6 1 1.17767702 0.63070688 0.95756614 -0.30129979 -0.1132809 0.1132809 2 2.73106894 0.79315491 -1.06746861 0.63455394 -0.6277589 0.6277589 3 -1.35304458 -0.88411918 -0.80694017 0.59275899 0.9040710 0.9040710 4 -0.03276446 -0.89302478 0.40289417 -0.02683564 0.4549365 0.4549365 5 0.53369832 -1.73600236 0.03584857 0.36659406 -0.3249856 0.3249856 6 0.49395437 -1.03698473 0.07879276 -0.39990796 0.1117328 0.1117328 7 -0.57098744 -0.01582456 -1.20817133 0.03857880 -0.1888670 0.1888670 8 0.08639052 0.96717754 -0.67848560 -0.94117668 -0.3054000 0.3054000 9 0.13038589 -0.22076719 -0.99625585 -0.52508619 1.8484595 1.8484595 10 -0.83919513 1.01093743 0.99035758 0.68735157 -0.1747314 0.1747314 Z7 Z8 1 0.01283257 -0.4756090 2 0.39408125 -0.1127605 3 0.81734435 0.2900747 4 0.20696721 -0.2908439 5 0.10561567 -0.3873039 6 0.01248422 -0.4759406 7 0.03567076 -0.4538731 8 0.09326918 -0.3990545 9 3.41680236 2.7640755 10 0.03053106 -0.4587647 . group_by() . sex = c(&quot;M&quot;,&quot;M&quot;,&quot;M&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;) value = c(1,2,3,10,20,30,40) . df = tibble(sex,value) df . sex value 1 M 1 2 M 2 3 M 3 4 F 10 5 F 20 6 F 30 7 F 40 . df %&gt;% group_by(sex) %&gt;% summarise(mean_value=mean(value)) . sex mean_value 1 F 25 2 M 2 . 그룹별로 묶은 다음에 평균을 계산함 | . - 신기한데? 다른것도 실습해보자. . df %&gt;% group_by(sex) %&gt;% summarise(sqrt_value=sqrt(value)) . `summarise()` has grouped output by &#39;sex&#39;. You can override using the `.groups` argument. . sex sqrt_value 1 F 3.162278 2 F 4.472136 3 F 5.477226 4 F 6.324555 5 M 1.000000 6 M 1.414214 7 M 1.732051 . 의도한 결과는 아님. 이렇게 쓰는건 아니에요! | . - 아래를 수행한 꼴임 . df %&gt;% mutate(sqrt_value=sqrt(value)) . sex value sqrt_value 1 M 1 1.000000 2 M 2 1.414214 3 M 3 1.732051 4 F 10 3.162278 5 F 20 4.472136 6 F 30 5.477226 7 F 40 6.324555 . - summarise에 쓸수 있는 함수꼴은 평균과 같이 $n$개의 벡터가 입력으로 올때 하나의 스칼라출력을 주는 함수모양이어야함 . - 예를들면 아래는 가능 . df %&gt;% group_by(sex) %&gt;% summarise(mean_sqrt_value=mean(sqrt(value))) . sex mean_sqrt_value 1 F 4.859049 2 M 1.382088 . (sqrt(1)+sqrt(2)+sqrt(3))/3 . [1] 1.382088 . (sqrt(10)+sqrt(20)+sqrt(30)+sqrt(40))/4 . [1] 4.859049 . - group_by + mutate . df %&gt;% group_by(sex) %&gt;% mutate(value2= value-mean(value)) . sex value value2 1 M 1 -1 2 M 2 0 3 M 3 1 4 F 10 -15 5 F 20 -5 6 F 30 5 7 F 40 15 . - 위의 코드는 아래와 동일하다. . df %&gt;% filter(sex==&#39;M&#39;) %&gt;% mutate(value2 = value - mean(value)) . sex value value2 1 M 1 -1 2 M 2 0 3 M 3 1 . df %&gt;% filter(sex==&#39;F&#39;) %&gt;% mutate(value2 = value - mean(value)) . sex value value2 1 F 10 -15 2 F 20 -5 3 F 30 5 4 F 40 15 . df %&gt;% filter(sex==&#39;M&#39;) %&gt;% mutate(value2 = value - mean(value)) -&gt; A1 df %&gt;% filter(sex==&#39;F&#39;) %&gt;% mutate(value2 = value - mean(value)) -&gt; A2 . A1 . sex value value2 1 M 1 -1 2 M 2 0 3 M 3 1 . A2 . sex value value2 1 F 10 -15 2 F 20 -5 3 F 30 5 4 F 40 15 . - 두 데이터프레임을 합치면 된다. (어떻게..??) . rbind(A1,A2) # 아 몰라.. 매트릭스처럼 하면 되지 않을까? . sex value value2 1 M 1 -1 2 M 2 0 3 M 3 1 4 F 10 -15 5 F 20 -5 6 F 30 5 7 F 40 15 . 된다... (떡밥) | . NA . - NA 포함되어도 개별연산은 괜찮아요 . x = c(1,2,NA,4,5) x . [1] 1 2 NA 4 5 . x+1 . [1] 2 3 NA 5 6 . x**2 . [1] 1 4 NA 16 25 . - 그런데 summarise에 쓸 연산은 망가져요 . mean(x) . [1] NA . max(x) . [1] NA . - 수정을 위해서 . mean(x,na.rm=TRUE) . [1] 3 . max(x,na.rm=TRUE) . [1] 5 . - 데이터프레임에서도 비슷합니다. . tibble(x) %&gt;% mutate(z=x+1) . x z 1 1 2 2 2 3 3 NA NA 4 4 5 5 5 6 . tibble(x) %&gt;% summarise(z=mean(x)) . z 1 NA . tibble(x) %&gt;% summarise(z=mean(x,na.rm=TRUE)) . z 1 3 . - NA를 무조건 없애는것이 좋은가? . x&lt;- c(1,2,NA,4) y&lt;- c(1,NA,3,4) z&lt;- c(NA,2,3,4) w&lt;- c(1,2,3,NA) . tibble(x,y,z,w) . x y z w 1 1 1 NA 1 2 2 NA 2 2 3 NA 3 3 3 4 4 4 4 NA . tibble(x,y,z,w) %&gt;% mutate(xy=x+y) . x y z w xy 1 1 1 NA 1 2 2 2 NA 2 2 NA 3 NA 3 3 3 NA 4 4 4 4 NA 8 . tibble(x,y,z,w) %&gt;% mutate(xy=x+y) %&gt;% summarise(mean_xy = mean(xy,na.rm=TRUE)) . mean_xy 1 5 . 그래도 NA를 살려두면 좋지않을까? 데이터 하나하나가 소중하니까요! | . - 결측치를 살릴까 죽일까? . x=c(1,2,3,4,NA,5,6,7) y=c(-1,-2,-3,-4,77,-5,-6,-7) . tibble(x,y) . x y 1 1 -1 2 2 -2 3 3 -3 4 4 -4 5 NA 77 6 5 -5 7 6 -6 8 7 -7 . tibble(x,y) %&gt;% filter(x&gt;3,x&lt;7) . x y 1 4 -4 2 5 -5 3 6 -6 . ?? y=77 은 죄없이 사라짐. 사실 보류로 봐야하지않나? NA는 3보다 크지 않지만 작지도 않음, 또한 7보다 크지 않지만 작지도 않음 | . - 결측치를 살리고 싶다. . tibble(x,y) %&gt;% filter(is.na(x)) . x y 1 NA 77 . tibble(x,y) %&gt;% filter(is.na(x) | (x&gt;3 &amp; x&lt;7)) . x y 1 4 -4 2 NA 77 3 5 -5 4 6 -6 . 데이터는 소중함 | . &#49892;&#49845; . library(nycflights13) . ref: https://r4ds.had.co.nz/transform.html | . df=flights df . year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time 1 2013 1 1 517 515 2 830 819 2 2013 1 1 533 529 4 850 830 3 2013 1 1 542 540 2 923 850 4 2013 1 1 544 545 -1 1004 1022 5 2013 1 1 554 600 -6 812 837 6 2013 1 1 554 558 -4 740 728 7 2013 1 1 555 600 -5 913 854 8 2013 1 1 557 600 -3 709 723 9 2013 1 1 557 600 -3 838 846 10 2013 1 1 558 600 -2 753 745 arr_delay carrier flight tailnum origin dest air_time distance hour 1 11 UA 1545 N14228 EWR IAH 227 1400 5 2 20 UA 1714 N24211 LGA IAH 227 1416 5 3 33 AA 1141 N619AA JFK MIA 160 1089 5 4 -18 B6 725 N804JB JFK BQN 183 1576 5 5 -25 DL 461 N668DN LGA ATL 116 762 6 6 12 UA 1696 N39463 EWR ORD 150 719 5 7 19 B6 507 N516JB EWR FLL 158 1065 6 8 -14 EV 5708 N829AS LGA IAD 53 229 6 9 -8 B6 79 N593JB JFK MCO 140 944 6 10 8 AA 301 N3ALAA LGA ORD 138 733 6 minute time_hour 1 15 2013-01-01 05:00:00 2 29 2013-01-01 05:00:00 3 40 2013-01-01 05:00:00 4 45 2013-01-01 05:00:00 5 0 2013-01-01 06:00:00 6 58 2013-01-01 05:00:00 7 0 2013-01-01 06:00:00 8 0 2013-01-01 06:00:00 9 0 2013-01-01 06:00:00 10 0 2013-01-01 06:00:00 [ reached getOption(&#34;max.print&#34;) -- omitted 51 rows ] . - 1월1일의 모든 항공편을 선택하고싶다. . df %&gt;% filter(month==1 &amp; day==1) . year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time 1 2013 1 1 517 515 2 830 819 2 2013 1 1 533 529 4 850 830 3 2013 1 1 542 540 2 923 850 4 2013 1 1 544 545 -1 1004 1022 5 2013 1 1 554 600 -6 812 837 6 2013 1 1 554 558 -4 740 728 7 2013 1 1 555 600 -5 913 854 8 2013 1 1 557 600 -3 709 723 9 2013 1 1 557 600 -3 838 846 10 2013 1 1 558 600 -2 753 745 arr_delay carrier flight tailnum origin dest air_time distance hour minute 1 11 UA 1545 N14228 EWR IAH 227 1400 5 15 2 20 UA 1714 N24211 LGA IAH 227 1416 5 29 3 33 AA 1141 N619AA JFK MIA 160 1089 5 40 4 -18 B6 725 N804JB JFK BQN 183 1576 5 45 5 -25 DL 461 N668DN LGA ATL 116 762 6 0 6 12 UA 1696 N39463 EWR ORD 150 719 5 58 7 19 B6 507 N516JB EWR FLL 158 1065 6 0 8 -14 EV 5708 N829AS LGA IAD 53 229 6 0 9 -8 B6 79 N593JB JFK MCO 140 944 6 0 10 8 AA 301 N3ALAA LGA ORD 138 733 6 0 time_hour 1 2013-01-01 05:00:00 2 2013-01-01 05:00:00 3 2013-01-01 05:00:00 4 2013-01-01 05:00:00 5 2013-01-01 06:00:00 6 2013-01-01 05:00:00 7 2013-01-01 06:00:00 8 2013-01-01 06:00:00 9 2013-01-01 06:00:00 10 2013-01-01 06:00:00 [ reached getOption(&#34;max.print&#34;) -- omitted 51 rows ] . df %&gt;% filter(month==1 , day==1) . year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time 1 2013 1 1 517 515 2 830 819 2 2013 1 1 533 529 4 850 830 3 2013 1 1 542 540 2 923 850 4 2013 1 1 544 545 -1 1004 1022 5 2013 1 1 554 600 -6 812 837 6 2013 1 1 554 558 -4 740 728 7 2013 1 1 555 600 -5 913 854 8 2013 1 1 557 600 -3 709 723 9 2013 1 1 557 600 -3 838 846 10 2013 1 1 558 600 -2 753 745 arr_delay carrier flight tailnum origin dest air_time distance hour minute 1 11 UA 1545 N14228 EWR IAH 227 1400 5 15 2 20 UA 1714 N24211 LGA IAH 227 1416 5 29 3 33 AA 1141 N619AA JFK MIA 160 1089 5 40 4 -18 B6 725 N804JB JFK BQN 183 1576 5 45 5 -25 DL 461 N668DN LGA ATL 116 762 6 0 6 12 UA 1696 N39463 EWR ORD 150 719 5 58 7 19 B6 507 N516JB EWR FLL 158 1065 6 0 8 -14 EV 5708 N829AS LGA IAD 53 229 6 0 9 -8 B6 79 N593JB JFK MCO 140 944 6 0 10 8 AA 301 N3ALAA LGA ORD 138 733 6 0 time_hour 1 2013-01-01 05:00:00 2 2013-01-01 05:00:00 3 2013-01-01 05:00:00 4 2013-01-01 05:00:00 5 2013-01-01 06:00:00 6 2013-01-01 05:00:00 7 2013-01-01 06:00:00 8 2013-01-01 06:00:00 9 2013-01-01 06:00:00 10 2013-01-01 06:00:00 [ reached getOption(&#34;max.print&#34;) -- omitted 51 rows ] . - 11월에 출발하거나 12월에 출발한 항공 . df %&gt;% filter(month==11 | month==12) . year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time 1 2013 11 1 5 2359 6 352 345 2 2013 11 1 35 2250 105 123 2356 3 2013 11 1 455 500 -5 641 651 4 2013 11 1 539 545 -6 856 827 5 2013 11 1 542 545 -3 831 855 6 2013 11 1 549 600 -11 912 923 7 2013 11 1 550 600 -10 705 659 8 2013 11 1 554 600 -6 659 701 9 2013 11 1 554 600 -6 826 827 10 2013 11 1 554 600 -6 749 751 arr_delay carrier flight tailnum origin dest air_time distance hour 1 7 B6 745 N568JB JFK PSE 205 1617 23 2 87 B6 1816 N353JB JFK SYR 36 209 22 3 -10 US 1895 N192UW EWR CLT 88 529 5 4 29 UA 1714 N38727 LGA IAH 229 1416 5 5 -24 AA 2243 N5CLAA JFK MIA 147 1089 5 6 -11 UA 303 N595UA JFK SFO 359 2586 6 7 6 US 2167 N748UW LGA DCA 57 214 6 8 -2 US 2134 N742PS LGA BOS 40 184 6 9 -1 DL 563 N912DE LGA ATL 126 762 6 10 -2 DL 731 N315NB LGA DTW 93 502 6 minute time_hour 1 59 2013-11-01 23:00:00 2 50 2013-11-01 22:00:00 3 0 2013-11-01 05:00:00 4 45 2013-11-01 05:00:00 5 45 2013-11-01 05:00:00 6 0 2013-11-01 06:00:00 7 0 2013-11-01 06:00:00 8 0 2013-11-01 06:00:00 9 0 2013-11-01 06:00:00 10 0 2013-11-01 06:00:00 [ reached getOption(&#34;max.print&#34;) -- omitted 51 rows ] . - 아래와 동일한 코드 . df %&gt;% filter(month %in% c(11,12)) . year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time 1 2013 11 1 5 2359 6 352 345 2 2013 11 1 35 2250 105 123 2356 3 2013 11 1 455 500 -5 641 651 4 2013 11 1 539 545 -6 856 827 5 2013 11 1 542 545 -3 831 855 6 2013 11 1 549 600 -11 912 923 7 2013 11 1 550 600 -10 705 659 8 2013 11 1 554 600 -6 659 701 9 2013 11 1 554 600 -6 826 827 10 2013 11 1 554 600 -6 749 751 arr_delay carrier flight tailnum origin dest air_time distance hour 1 7 B6 745 N568JB JFK PSE 205 1617 23 2 87 B6 1816 N353JB JFK SYR 36 209 22 3 -10 US 1895 N192UW EWR CLT 88 529 5 4 29 UA 1714 N38727 LGA IAH 229 1416 5 5 -24 AA 2243 N5CLAA JFK MIA 147 1089 5 6 -11 UA 303 N595UA JFK SFO 359 2586 6 7 6 US 2167 N748UW LGA DCA 57 214 6 8 -2 US 2134 N742PS LGA BOS 40 184 6 9 -1 DL 563 N912DE LGA ATL 126 762 6 10 -2 DL 731 N315NB LGA DTW 93 502 6 minute time_hour 1 59 2013-11-01 23:00:00 2 50 2013-11-01 22:00:00 3 0 2013-11-01 05:00:00 4 45 2013-11-01 05:00:00 5 45 2013-11-01 05:00:00 6 0 2013-11-01 06:00:00 7 0 2013-11-01 06:00:00 8 0 2013-11-01 06:00:00 9 0 2013-11-01 06:00:00 10 0 2013-11-01 06:00:00 [ reached getOption(&#34;max.print&#34;) -- omitted 51 rows ] . - arr_delay &lt;=120 이고 dep_delay &lt;=120 인 항공편을 찾고 싶다. . df %&gt;% filter(arr_delay &lt;= 120, dep_delay&lt;=120) . year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time 1 2013 1 1 517 515 2 830 819 2 2013 1 1 533 529 4 850 830 3 2013 1 1 542 540 2 923 850 4 2013 1 1 544 545 -1 1004 1022 5 2013 1 1 554 600 -6 812 837 6 2013 1 1 554 558 -4 740 728 7 2013 1 1 555 600 -5 913 854 8 2013 1 1 557 600 -3 709 723 9 2013 1 1 557 600 -3 838 846 10 2013 1 1 558 600 -2 753 745 arr_delay carrier flight tailnum origin dest air_time distance hour 1 11 UA 1545 N14228 EWR IAH 227 1400 5 2 20 UA 1714 N24211 LGA IAH 227 1416 5 3 33 AA 1141 N619AA JFK MIA 160 1089 5 4 -18 B6 725 N804JB JFK BQN 183 1576 5 5 -25 DL 461 N668DN LGA ATL 116 762 6 6 12 UA 1696 N39463 EWR ORD 150 719 5 7 19 B6 507 N516JB EWR FLL 158 1065 6 8 -14 EV 5708 N829AS LGA IAD 53 229 6 9 -8 B6 79 N593JB JFK MCO 140 944 6 10 8 AA 301 N3ALAA LGA ORD 138 733 6 minute time_hour 1 15 2013-01-01 05:00:00 2 29 2013-01-01 05:00:00 3 40 2013-01-01 05:00:00 4 45 2013-01-01 05:00:00 5 0 2013-01-01 06:00:00 6 58 2013-01-01 05:00:00 7 0 2013-01-01 06:00:00 8 0 2013-01-01 06:00:00 9 0 2013-01-01 06:00:00 10 0 2013-01-01 06:00:00 [ reached getOption(&#34;max.print&#34;) -- omitted 51 rows ] . df %&gt;% filter(arr_delay &lt;= 120 &amp; dep_delay&lt;=120) . year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time 1 2013 1 1 517 515 2 830 819 2 2013 1 1 533 529 4 850 830 3 2013 1 1 542 540 2 923 850 4 2013 1 1 544 545 -1 1004 1022 5 2013 1 1 554 600 -6 812 837 6 2013 1 1 554 558 -4 740 728 7 2013 1 1 555 600 -5 913 854 8 2013 1 1 557 600 -3 709 723 9 2013 1 1 557 600 -3 838 846 10 2013 1 1 558 600 -2 753 745 arr_delay carrier flight tailnum origin dest air_time distance hour 1 11 UA 1545 N14228 EWR IAH 227 1400 5 2 20 UA 1714 N24211 LGA IAH 227 1416 5 3 33 AA 1141 N619AA JFK MIA 160 1089 5 4 -18 B6 725 N804JB JFK BQN 183 1576 5 5 -25 DL 461 N668DN LGA ATL 116 762 6 6 12 UA 1696 N39463 EWR ORD 150 719 5 7 19 B6 507 N516JB EWR FLL 158 1065 6 8 -14 EV 5708 N829AS LGA IAD 53 229 6 9 -8 B6 79 N593JB JFK MCO 140 944 6 10 8 AA 301 N3ALAA LGA ORD 138 733 6 minute time_hour 1 15 2013-01-01 05:00:00 2 29 2013-01-01 05:00:00 3 40 2013-01-01 05:00:00 4 45 2013-01-01 05:00:00 5 0 2013-01-01 06:00:00 6 58 2013-01-01 05:00:00 7 0 2013-01-01 06:00:00 8 0 2013-01-01 06:00:00 9 0 2013-01-01 06:00:00 10 0 2013-01-01 06:00:00 [ reached getOption(&#34;max.print&#34;) -- omitted 51 rows ] . df %&gt;% filter(!(arr_delay &gt; 120 | dep_delay&gt; 120)) . year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time 1 2013 1 1 517 515 2 830 819 2 2013 1 1 533 529 4 850 830 3 2013 1 1 542 540 2 923 850 4 2013 1 1 544 545 -1 1004 1022 5 2013 1 1 554 600 -6 812 837 6 2013 1 1 554 558 -4 740 728 7 2013 1 1 555 600 -5 913 854 8 2013 1 1 557 600 -3 709 723 9 2013 1 1 557 600 -3 838 846 10 2013 1 1 558 600 -2 753 745 arr_delay carrier flight tailnum origin dest air_time distance hour 1 11 UA 1545 N14228 EWR IAH 227 1400 5 2 20 UA 1714 N24211 LGA IAH 227 1416 5 3 33 AA 1141 N619AA JFK MIA 160 1089 5 4 -18 B6 725 N804JB JFK BQN 183 1576 5 5 -25 DL 461 N668DN LGA ATL 116 762 6 6 12 UA 1696 N39463 EWR ORD 150 719 5 7 19 B6 507 N516JB EWR FLL 158 1065 6 8 -14 EV 5708 N829AS LGA IAD 53 229 6 9 -8 B6 79 N593JB JFK MCO 140 944 6 10 8 AA 301 N3ALAA LGA ORD 138 733 6 minute time_hour 1 15 2013-01-01 05:00:00 2 29 2013-01-01 05:00:00 3 40 2013-01-01 05:00:00 4 45 2013-01-01 05:00:00 5 0 2013-01-01 06:00:00 6 58 2013-01-01 05:00:00 7 0 2013-01-01 06:00:00 8 0 2013-01-01 06:00:00 9 0 2013-01-01 06:00:00 10 0 2013-01-01 06:00:00 [ reached getOption(&#34;max.print&#34;) -- omitted 51 rows ] . - 변수이름을 확인하자. . df %&gt;% colnames . [1] &#34;year&#34; &#34;month&#34; &#34;day&#34; &#34;dep_time&#34; [5] &#34;sched_dep_time&#34; &#34;dep_delay&#34; &#34;arr_time&#34; &#34;sched_arr_time&#34; [9] &#34;arr_delay&#34; &#34;carrier&#34; &#34;flight&#34; &#34;tailnum&#34; [13] &#34;origin&#34; &#34;dest&#34; &#34;air_time&#34; &#34;distance&#34; [17] &#34;hour&#34; &#34;minute&#34; &#34;time_hour&#34; . df %&gt;% names . [1] &#34;year&#34; &#34;month&#34; &#34;day&#34; &#34;dep_time&#34; [5] &#34;sched_dep_time&#34; &#34;dep_delay&#34; &#34;arr_time&#34; &#34;sched_arr_time&#34; [9] &#34;arr_delay&#34; &#34;carrier&#34; &#34;flight&#34; &#34;tailnum&#34; [13] &#34;origin&#34; &#34;dest&#34; &#34;air_time&#34; &#34;distance&#34; [17] &#34;hour&#34; &#34;minute&#34; &#34;time_hour&#34; . 왜 방법이 두개있을까? (떡밥) | . - 변수가 너무 많아서 귀찮음. 몇개만 추리자. . year~day 는 포함 | delay로 끝나는 변수들 | distance, air_time | . df %&gt;% select(year:day, ends_with(&#39;delay&#39;), distance, air_time) . year month day dep_delay arr_delay distance air_time 1 2013 1 1 2 11 1400 227 2 2013 1 1 4 20 1416 227 3 2013 1 1 2 33 1089 160 4 2013 1 1 -1 -18 1576 183 5 2013 1 1 -6 -25 762 116 6 2013 1 1 -4 12 719 150 7 2013 1 1 -5 19 1065 158 8 2013 1 1 -3 -14 229 53 9 2013 1 1 -3 -8 944 140 10 2013 1 1 -2 8 733 138 11 2013 1 1 -2 -2 1028 149 12 2013 1 1 -2 -3 1005 158 13 2013 1 1 -2 7 2475 345 14 2013 1 1 -2 -14 2565 361 15 2013 1 1 -1 31 1389 257 16 2013 1 1 0 -4 187 44 17 2013 1 1 -1 -8 2227 337 18 2013 1 1 0 -7 1076 152 19 2013 1 1 0 12 762 134 20 2013 1 1 1 -6 1023 147 21 2013 1 1 -8 -8 1020 170 22 2013 1 1 -3 16 502 105 23 2013 1 1 -4 -12 1085 152 24 2013 1 1 -4 -8 760 128 25 2013 1 1 0 -17 1085 157 26 2013 1 1 8 32 719 139 27 2013 1 1 11 14 2586 366 28 2013 1 1 3 4 1074 175 [ reached getOption(&#34;max.print&#34;) -- omitted 33 rows ] . - 아래의 수식을 이용해서 gain, speed를 계산하자. . gain = dep_delay - arr_delay | speed = distance / air_time | . df %&gt;% select(year:day, ends_with(&#39;delay&#39;), distance, air_time) %&gt;% mutate(gain = dep_delay - arr_delay, speed = distance / air_time) . year month day dep_delay arr_delay distance air_time gain speed 1 2013 1 1 2 11 1400 227 -9 6.167401 2 2013 1 1 4 20 1416 227 -16 6.237885 3 2013 1 1 2 33 1089 160 -31 6.806250 4 2013 1 1 -1 -18 1576 183 17 8.612022 5 2013 1 1 -6 -25 762 116 19 6.568966 6 2013 1 1 -4 12 719 150 -16 4.793333 7 2013 1 1 -5 19 1065 158 -24 6.740506 8 2013 1 1 -3 -14 229 53 11 4.320755 9 2013 1 1 -3 -8 944 140 5 6.742857 10 2013 1 1 -2 8 733 138 -10 5.311594 11 2013 1 1 -2 -2 1028 149 0 6.899329 12 2013 1 1 -2 -3 1005 158 1 6.360759 13 2013 1 1 -2 7 2475 345 -9 7.173913 14 2013 1 1 -2 -14 2565 361 12 7.105263 15 2013 1 1 -1 31 1389 257 -32 5.404669 16 2013 1 1 0 -4 187 44 4 4.250000 17 2013 1 1 -1 -8 2227 337 7 6.608309 18 2013 1 1 0 -7 1076 152 7 7.078947 19 2013 1 1 0 12 762 134 -12 5.686567 20 2013 1 1 1 -6 1023 147 7 6.959184 21 2013 1 1 -8 -8 1020 170 0 6.000000 22 2013 1 1 -3 16 502 105 -19 4.780952 [ reached getOption(&#34;max.print&#34;) -- omitted 39 rows ] . - year, month, day 로 그룹핑을하고 평균속도와 평균gain을 계산해보자. . df %&gt;% select(year:day, ends_with(&#39;delay&#39;), distance, air_time) %&gt;% mutate(gain = dep_delay - arr_delay, speed = distance / air_time) %&gt;% group_by(year,month,day) %&gt;% summarise(gain_mean=mean(gain),speed_mean=mean(speed)) . `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. . year month day gain_mean speed_mean 1 2013 1 1 NA NA 2 2013 1 2 NA NA 3 2013 1 3 NA NA 4 2013 1 4 NA NA 5 2013 1 5 NA NA 6 2013 1 6 NA NA 7 2013 1 7 NA NA 8 2013 1 8 NA NA 9 2013 1 9 NA NA 10 2013 1 10 NA NA 11 2013 1 11 NA NA 12 2013 1 12 NA NA 13 2013 1 13 NA NA 14 2013 1 14 NA NA 15 2013 1 15 NA NA 16 2013 1 16 NA NA 17 2013 1 17 NA NA 18 2013 1 18 NA NA 19 2013 1 19 NA NA 20 2013 1 20 NA NA 21 2013 1 21 NA NA 22 2013 1 22 NA NA 23 2013 1 23 NA NA 24 2013 1 24 NA NA 25 2013 1 25 NA NA 26 2013 1 26 NA NA 27 2013 1 27 NA NA 28 2013 1 28 NA NA 29 2013 1 29 NA NA 30 2013 1 30 NA NA ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ 336 2013 12 2 NA NA 337 2013 12 3 NA NA 338 2013 12 4 NA NA 339 2013 12 5 NA NA 340 2013 12 6 NA NA 341 2013 12 7 NA NA 342 2013 12 8 NA NA 343 2013 12 9 NA NA 344 2013 12 10 NA NA [ reached getOption(&#34;max.print&#34;) -- omitted 21 rows ] . 다 NA가 나옴.. | . df %&gt;% select(year:day, ends_with(&#39;delay&#39;), distance, air_time) %&gt;% mutate(gain = dep_delay - arr_delay, speed = distance / air_time) %&gt;% group_by(year,month,day) %&gt;% summarise(gain_mean=mean(gain,na.rm=TRUE),speed_mean=mean(speed,na.rm=TRUE)) . `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. . year month day gain_mean speed_mean 1 2013 1 1 -1.2154031 5.956879 2 2013 1 2 0.9849138 6.085977 3 2013 1 3 5.1744444 6.163061 4 2013 1 4 10.8986784 6.389652 5 2013 1 5 7.2580195 6.259174 6 2013 1 6 2.9095296 6.146544 7 2013 1 7 10.3645161 6.488469 8 2013 1 8 5.7858744 6.215331 9 2013 1 9 2.5655095 6.021767 10 2013 1 10 8.7438105 6.375353 11 2013 1 11 7.5954198 6.326487 12 2013 1 12 14.6093979 6.613691 13 2013 1 13 4.6877323 6.353392 14 2013 1 14 -0.8418202 6.018617 15 2013 1 15 -0.3019296 5.918271 16 2013 1 16 -9.7924971 5.819344 17 2013 1 17 1.1923497 5.923112 18 2013 1 18 4.9263736 6.207338 19 2013 1 19 11.8882265 6.340853 20 2013 1 20 3.0640205 6.098927 21 2013 1 21 1.5232816 5.911828 22 2013 1 22 0.2225989 5.966793 23 2013 1 23 3.6925676 6.081496 24 2013 1 24 4.1156388 6.305144 25 2013 1 25 -5.3469852 6.177677 26 2013 1 26 6.4619970 6.342779 27 2013 1 27 9.6972705 6.371808 28 2013 1 28 5.7794632 6.288730 29 2013 1 29 9.1047181 6.297918 30 2013 1 30 2.0226131 6.072084 ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ 336 2013 12 2 8.6172345 6.538165 337 2013 12 3 3.7637306 6.385837 338 2013 12 4 5.5354497 6.374694 339 2013 12 5 0.7886279 6.315847 340 2013 12 6 -4.9424779 6.088300 341 2013 12 7 -0.5210210 6.083830 342 2013 12 8 -16.0335404 6.015119 343 2013 12 9 -7.9688889 5.927017 344 2013 12 10 -18.0433018 5.851833 [ reached getOption(&#34;max.print&#34;) -- omitted 21 rows ] . &#49689;&#51228; . 강화유리와 유리를 구분할 수 있는 유리 장인이 있다. . 이 유리장인은 80퍼센트의 확률로 강화유리를 고른다. . 총 10명의 참가자가 있고 이 참가자들은 (유리,강화유리)의 조합으로 이루어진 징검다리를 5번연속으로 건너야 한다. . 아래의 경우에 참가자들은 평균적으로 몇명이 살아남겠는가? . (1) 일반인1 - 일반인2 - .... - 일반인9 - 유리장인 || (강화유리, 유리) . (2) 유리장인 - 일반인1 - 일반인2 - ... - 일반인9 || (강화유리, 유리) . 1000번 시뮬레이션을 하여 결과를 추정하라. . (단, 일반인은 50%의 확률로 강화유리를 고를수 있다고 하자) . . [예시] (1)의 시뮬레이션 결과가 아래와 같다고 하자. . 첫번째 징검다리: 유리장인이 강화유리 선택 | 두번째 징검다리: 유리장인이 강화유리 선택 | 세번째 징검다리: 유리장인이 일반유리 선택 $ to$ 유리장인 탈락 &amp; 일반인9는 당연히 강화유리를 선택 | 네번째 징검다리: 일반인9가 일반유리 선택 $ to$ 일반인9 탈락 &amp; 일반인8은 당연히 강화유리 선택 | 다섯번째 징검다리: 일반인8이 강화유리 선택 | . 이 경우는 일반인8,일반인7, $ dots$, 일반인1이 살아남으므로 8명이 살아남는다. . [예시] (2)의 시뮬레이션 결과가 아래와 같다고 하자. . 첫번째 징검다리: 일반인9 일반유리 선택 $ to$ 일반인9 탈락 &amp; 일반인8은 강화유리 선택 | 두번째 징검다리: 일반인8 일반유리 선택 $ to$ 일반인8 탈락 &amp; 일반인7은 강화유리 선택 | 세번째 징검다리: 일반인7 일반유리 선택 $ to$ 일반인7 탈락 &amp; 일반인6은 강화유리 선택 | 네번째 징검다리: 일반인6 일반유리 선택 $ to$ 일반인6 탈락 &amp; 일반인5는 강화유리 선택 | 다섯번째 징검다리: 일반인5 일반유리 선택 $ to$ 일반인5 탈락 &amp; 일반인4는 강화유리 선택 | . 이 경우는 일반인4,일반인3,일반인2,일반인1,유리장인 이 살아남는다. (따라서 5명) . - 즉 살아남을수 있는 최대인원수는 10명이며 최소인원수는 5명이다. . - 유리장인이 100%의 확률로 강화유리를 구분한다면 (1)의 경우 항상 10명이 살아남는다. (즉 평균도 10명) . (1) . 10명이 전부 살아남는 경우 = $0.5^5$ | . - 9명이 살아남는 경우 . 일반인1이 1번째 탈락 = $0.5^0 times 0.5 times 0.5^4$ = $0.5^5$ | 일반인1이 2번째 탈락 = $0.5^1 times 0.5 times 0.5^3$ = $0.5^5$ | 일반인1이 3번째 탈락 = $0.5^2 times 0.5 times 0.5^2$ = $0.5^5$ | 일반인1이 4번째 탈락 = $0.5^3 times 0.5 times 0.5^1$ = $0.5^5$ | 일반인1이 5번째 탈락 = $0.5^4 times 0.5 times 0.5^0$ = $0.5^5$ | . 확률은 동일하게 $0.5^5$이므로, 경우가 중요 . - 8 명이 살아남는 결우 . 일반인1이 1번째 탈락 = $choose(4,1) times 0.5^5$ 일반인2가 2번째 탈락 | 일반인2가 3번째 탈락 | 일반인2가 4번째 탈락 | 일반인2가 5번째 탈락 | . | 일반인1이 2번째 탈락 = $choose(3,1) times 0.5^5$ 일반인2가 3번째 탈락 | 일반인2가 4번째 탈락 | 일반인2가 5번째 탈락 | . | 일반인1이 3번째 탈락 = $choose(2,1) times 0.5^5$ 일반인2가 4번째 탈락 | 일반인2가 5번째 탈락 | . | 일반인1이 4번째 탈락 = $choose(1,1) times 0.5^5$ 일반인2가 5번째 탈락 | . | . - 7명이 살아남을 확률? . 일반인1이 1번째 탈락 = $choose(4,2) times 0.5^5$ 일반인이 2,3번째 탈락 | 일반인이 2,4번째 탈락 | 일반인이 2,5번째 탈락 | 일반인이 3,4번째 탈락 | 일반인이 3,5번째 탈락 | 일반인이 4,5번째 탈락 | . | 일반인1이 2번째 탈락 = $choose(3,2) times 0.5^5$ 일반인이 3,4번째 탈락 | 일반인이 3,5번째 탈락 | 일반인이 4,5번째 탈락 | . | 일반인1이 3번째 탈락 = $choose(2,2) times 0.5^5$ 일반인이 4,5번째 탈락 | . | . - 6명이 살아남을 확률? . 일반인1이 1번째 탈락 = $choose(4,3) times 0.5^5$ 일반인이 2,3,4번째 탈락 | 일반인이 2,3,5번째 탈락 | 일반인이 2,4,5번째 탈락 | 일반인이 3,4,5번째 탈락 | . | 일반인1이 2번째 탈락 = $1 times 0.5^3$ 일반인이 3,4,5번째 탈락 | . | . - 5명이 살아남을 확률? $0.5^5$ . 일반인5명 연속탈락 | . surv10_prob1 = 0.5^5 . surv9_prob1 = c() for (i in 0:4) surv9_prob1[i+1] = 0.5^5 . surv8_prob1 = c() for (i in 0:3) surv8_prob1[i+1] = choose(4-i,1)*0.5^5 . surv7_prob1 = c() for (i in 0:2) surv7_prob1[i+1] = choose(4-i,2)*0.5^5 . surv6_prob1 = c() for (i in 0:1) surv6_prob1[i+1] = choose(4-i,3)*0.5^5 . surv5_prob1 = 0.5^5 . surv10_prob1*10 + sum(surv9_prob1)*9 + sum(surv8_prob1)*8 + sum(surv7_prob1)*7 + sum(surv6_prob1)*6 + surv5_prob1*5 . 7.5 (2) . 10명이 전부 살아남는 경우 = $0.8^5$ | . - 9명이 살아남는 경우 . 장인이 1번째 탈락 = $0.8^0 times 0.2 times 0.5^4$ | 장인이 2번째 탈락 = $0.8^1 times 0.2 times 0.5^3$ | 장인이 3번째 탈락 = $0.8^2 times 0.2 times 0.5^2$ | 장인이 4번째 탈락 = $0.8^3 times 0.2 times 0.5^1$ | 장인이 5번째 탈락 = $0.8^4 times 0.2 times 0.5^0$ | . - 8 명이 살아남는 결우 . 장인이 1번째 탈락 = $choose(4,1) times 0.8^0 times 0.2 times 0.5^4$ 일반인1이 2번째 탈락 | 일반인1이 3번째 탈락 | 일반인1이 4번째 탈락 | 일반인1이 5번째 탈락 | . | 장인이 2번째 탈락 = $choose(3,1) times 0.8^1 times 0.2 times 0.5^3$ 일반인1이 3번째 탈락 | 일반인1이 4번째 탈락 | 일반인1이 5번째 탈락 | . | 장인이 3번째 탈락 = $choose(2,1) times 0.8^2 times 0.2 times 0.5^3$ 일반인1이 4번째 탈락 | 일반인1이 5번째 탈락 | . | 장인이 4번째 탈락 = $choose(1,1) times 0.8^3 times 0.2 times 0.5^2$ 일반인1이 5번째 탈락 | . | . - 7명이 살아남을 확률? . 장인이 1번째 탈락 = $choose(4,2) times 0.8^0 times 0.2 times 0.5^4$ 일반인이 2,3번째 탈락 | 일반인이 2,4번째 탈락 | 일반인이 2,5번째 탈락 | 일반인이 3,4번째 탈락 | 일반인이 3,5번째 탈락 | 일반인이 4,5번째 탈락 | . | 장인이 2번째 탈락 = $choose(3,2) times 0.8^1 times 0.2 times 0.5^3$ 일반인이 3,4번째 탈락 | 일반인이 3,5번째 탈락 | 일반인이 4,5번째 탈락 | . | 일반인1이 3번째 탈락 = $choose(2,2) times 0.8^3 times 0.2 times 0.5^2$ 일반인이 4,5번째 탈락 | . | . - 6명이 살아남을 확률? . 장인이 1번째 탈락 = $choose(4,3) times 0.8^0 times 0.2 times 0.5^4$ 일반인이 2,3,4번째 탈락 | 일반인이 2,3,5번째 탈락 | 일반인이 2,4,5번째 탈락 | 일반인이 3,4,5번째 탈락 | . | 장인이 2번째 탈락 = $1 times 0.8^1 times 0.2 times 0.5^3$ 일반인이 3,4,5번째 탈락 | . | . - 5명이 살아남을 확률? 0.8^0 times 0.2 times 0.5^4$ . 장인 + 일반인4명 연속탈락 | . surv10_prob2 = 0.8^5 . surv9_prob2 = c() for (i in 0:4) surv9_prob2[i+1] = 0.8^i*0.2*0.5^(4-i) . surv8_prob2 = c() for (i in 0:3) surv8_prob2[i+1] = choose(4-i,1)*0.8^i*0.2*0.5^(4-i) . surv7_prob2 = c() for (i in 0:2) surv7_prob2[i+1] = choose(4-i,2)*0.8^i*0.2*0.5^(4-i) . surv6_prob2 = c() for (i in 0:1) surv6_prob2[i+1] = choose(4-i,3)*0.8^i*0.2*0.5^(4-i) . surv5_prob2 = 0.2*0.5^4 . surv10_prob2*10 + sum(surv9_prob2)*9 + sum(surv8_prob2)*8 + sum(surv7_prob2)*7 + sum(surv6_prob2)*6 + surv5_prob2*5 . 8.50848",
            "url": "https://sempre39.github.io/econ_blog/2022/01/21/_11_30_(12%EC%A3%BC%EC%B0%A8)_11%EC%9B%9430%EC%9D%BC,_11%EC%9B%9425%EC%9D%BC_%EB%B3%B4%EA%B0%95.html",
            "relUrl": "/2022/01/21/_11_30_(12%EC%A3%BC%EC%B0%A8)_11%EC%9B%9430%EC%9D%BC,_11%EC%9B%9425%EC%9D%BC_%EB%B3%B4%EA%B0%95.html",
            "date": " • Jan 21, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "(11주차) 11월23일",
            "content": "library(tidyverse) . &#51669;&#44160;&#45796;&#47532;&#47928;&#51228;&#54400;&#51060; . (&#54400;&#51060;1) . - (유리, 강화유리) . set = c(&#39;tempered glass&#39;,&#39;glass&#39;) set . [1] &#34;tempered glass&#34; &#34;glass&#34; . - sample을 이용하여 0.8의 확률로 강화유리를 뽑음 . sample(size=5, set, prob=c(0.8,0.2),replace=T) . [1] &#34;tempered glass&#34; &#34;tempered glass&#34; &#34;tempered glass&#34; &#34;glass&#34; [5] &#34;tempered glass&#34; . - 함수로 보기좋게 만들자. . simulate_once = function() sample(size=5, set, prob=c(0.8,0.2),replace=T) #입력이 없는 함수 . simulate_once() . [1] &#34;glass&#34; &#34;tempered glass&#34; &#34;tempered glass&#34; &#34;tempered glass&#34; [5] &#34;tempered glass&#34; . - 뽑은결과를 바탕으로 사망유무를 판단 . a = simulate_once() a . [1] &#34;tempered glass&#34; &#34;tempered glass&#34; &#34;tempered glass&#34; &#34;glass&#34; [5] &#34;tempered glass&#34; . a[1] == &quot;tempered glass&quot; &amp; a[2] == &quot;tempered glass&quot; &amp; a[3] == &quot;tempered glass&quot; &amp; a[4] == &quot;tempered glass&quot; &amp; a[5] == &quot;tempered glass&quot; . [1] FALSE . 조건 | . - 위의 조건이 참이면 b=1, 참이 아니라면 b=0 . if (a[1] == &quot;tempered glass&quot; &amp; a[2] == &quot;tempered glass&quot; &amp; a[3] == &quot;tempered glass&quot; &amp; a[4] == &quot;tempered glass&quot; &amp; a[5] == &quot;tempered glass&quot;){ b=1 }else{ b=0} . b . [1] 0 . - 함수로 정리하자. . test = function(a){ if (a[1] == &quot;tempered glass&quot; &amp; a[2] == &quot;tempered glass&quot; &amp; a[3] == &quot;tempered glass&quot; &amp; a[4] == &quot;tempered glass&quot; &amp; a[5] == &quot;tempered glass&quot;) b=1 else b=0 b } . a=simulate_once() print(a) test(a) . [1] &#34;tempered glass&#34; &#34;tempered glass&#34; &#34;tempered glass&#34; &#34;tempered glass&#34; [5] &#34;tempered glass&#34; . [1] 1 . - 답을 구해보자 . sum_ = 0 for (i in 1:1000) sum_ = sum_ + test(simulate_once()) . sum_ . [1] 322 . (&#54400;&#51060;2) . - 시행결과를 벡터로하는 편이 좋겠다. . set = c(&#39;tempered glass&#39;,&#39;glass&#39;) simulate_once = function() sample(size=5, set, prob=c(0.8,0.2),replace=T) #입력이 없는 함수 test = function(a){ if (a[1] == &quot;tempered glass&quot; &amp; a[2] == &quot;tempered glass&quot; &amp; a[3] == &quot;tempered glass&quot; &amp; a[4] == &quot;tempered glass&quot; &amp; a[5] == &quot;tempered glass&quot;) b=1 else b=0 b } # sum_ = 0 # for (i in 1:1000) sum_ = sum_ + test(simulate_once()) 컨트롤+/ (Rstudio: 컨트롤+쉬프트+c) rslt = c() for (i in 1:1000) rslt[i] = test(simulate_once()) . rslt . [1] 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 [38] 0 0 0 1 0 0 0 1 1 0 0 1 0 1 0 0 1 0 1 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 1 [75] 0 1 1 1 1 0 1 1 1 0 1 0 0 1 0 1 1 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 [112] 0 0 1 0 1 0 1 0 1 0 0 0 0 1 0 0 0 1 1 1 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 1 1 [149] 1 0 0 0 0 1 0 0 1 1 1 0 0 1 1 1 0 1 0 1 0 0 1 0 1 1 0 1 0 1 0 0 1 1 1 0 0 [186] 0 1 0 0 1 0 0 1 0 0 0 0 0 1 0 [ reached getOption(&#34;max.print&#34;) -- omitted 800 entries ] . sum(rslt) . [1] 317 . (&#54400;&#51060;3) . - 시뮬레이션 결과를 매트릭스에 저장하면 더 디버깅이 용이하다. . mat = rep(0,1000*5) dim(mat) = c(1000,5) head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] 0 0 0 0 0 [2,] 0 0 0 0 0 [3,] 0 0 0 0 0 [4,] 0 0 0 0 0 [5,] 0 0 0 0 0 [6,] 0 0 0 0 0 . mat[1,] . [1] 0 0 0 0 0 . mat[1,] = simulate_once() . head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] glass tempered glass tempered glass tempered glass glass [2,] 0 0 0 0 0 [3,] 0 0 0 0 0 [4,] 0 0 0 0 0 [5,] 0 0 0 0 0 [6,] 0 0 0 0 0 . for (i in 1:1000) mat[i,] = simulate_once() . head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] tempered glass tempered glass tempered glass tempered glass tempered glass [2,] glass tempered glass tempered glass tempered glass glass [3,] tempered glass tempered glass tempered glass tempered glass tempered glass [4,] tempered glass tempered glass tempered glass tempered glass tempered glass [5,] tempered glass tempered glass glass glass tempered glass [6,] tempered glass tempered glass tempered glass glass tempered glass . rslt=c() for (i in 1:1000) rslt[i] = test(mat[i,]) . rslt[1:5] . [1] 1 0 1 1 0 . mat[1:5,] . [,1] [,2] [,3] [,4] [,5] [1,] tempered glass tempered glass tempered glass tempered glass tempered glass [2,] glass tempered glass tempered glass tempered glass glass [3,] tempered glass tempered glass tempered glass tempered glass tempered glass [4,] tempered glass tempered glass tempered glass tempered glass tempered glass [5,] tempered glass tempered glass glass glass tempered glass . - 정리하면 . set = c(&#39;tempered glass&#39;,&#39;glass&#39;) simulate_once = function() sample(size=5, set, prob=c(0.8,0.2),replace=T) #입력이 없는 함수 test = function(a){ if (a[1] == &quot;tempered glass&quot; &amp; a[2] == &quot;tempered glass&quot; &amp; a[3] == &quot;tempered glass&quot; &amp; a[4] == &quot;tempered glass&quot; &amp; a[5] == &quot;tempered glass&quot;) b=1 else b=0 b } mat = rep(0,1000*5) dim(mat) = c(1000,5) rslt = c() # for (i in 1:1000) rslt[i] = test(simulate_once()) for (i in 1:1000){ mat[i,] = simulate_once() rslt[i] = test(mat[i,]) } sum(rslt) . [1] 329 . (&#54400;&#51060;4) . - 어차피 mat 매트릭스만 만들면 되니까 . set = c(&#39;tempered glass&#39;,&#39;glass&#39;) mat= sample(size=1000*5, set, prob=c(0.8,0.2),replace=T) #입력이 없는 함수 dim(mat)=c(1000,5) . head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] glass tempered glass glass tempered glass tempered glass [2,] tempered glass tempered glass glass tempered glass glass [3,] tempered glass tempered glass tempered glass glass glass [4,] tempered glass tempered glass tempered glass glass tempered glass [5,] tempered glass tempered glass tempered glass tempered glass tempered glass [6,] tempered glass tempered glass tempered glass tempered glass tempered glass . test = function(a){ if (a[1] == &quot;tempered glass&quot; &amp; a[2] == &quot;tempered glass&quot; &amp; a[3] == &quot;tempered glass&quot; &amp; a[4] == &quot;tempered glass&quot; &amp; a[5] == &quot;tempered glass&quot;) b=1 else b=0 b } rslt = c() for (i in 1:1000){ rslt[i] = test(mat[i,]) } sum(rslt) . [1] 326 . (&#54400;&#51060;5) . - 매트릭스의 원소가 꼭 문자열일 필요는 없는것 같음 . set = c(1,0) mat= sample(size=1000*5, set, prob=c(0.8,0.2),replace=T) #입력이 없는 함수 dim(mat)=c(1000,5) . head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] 1 1 1 1 1 [2,] 1 0 1 1 1 [3,] 1 1 1 1 1 [4,] 0 1 1 0 1 [5,] 1 1 1 1 1 [6,] 0 1 1 1 1 . test = function(a){ if (a[1] == 1 &amp; a[2] == 1 &amp; a[3] == 1 &amp; a[4] == 1 &amp; a[5] == 1) b=1 else b=0 b } rslt = c() for (i in 1:1000){ rslt[i] = test(mat[i,]) } sum(rslt) . [1] 355 . - 조건도 아래와 같이 간소화할 수있다. . test = function(a){ if (sum(a)==5) b=1 else b=0 b } rslt = c() for (i in 1:1000){ rslt[i] = test(mat[i,]) } sum(rslt) . [1] 355 . - 아래와 같이 바꿔도 가능 . test = function(a){ if (prod(a)==1) b=1 else b=0 b } rslt = c() for (i in 1:1000){ rslt[i] = test(mat[i,]) } sum(rslt) . [1] 355 . - test함수 자체도 아래와 같이 간소화 가능 . test = function(a){ prod(c(1,0,1,1,1))==1 } . - 정리하면 . set = c(1,0) mat= sample(size=1000*5, set, prob=c(0.8,0.2),replace=T) #입력이 없는 함수 dim(mat)=c(1000,5) head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] 1 1 1 1 1 [2,] 1 1 1 0 1 [3,] 0 0 1 1 1 [4,] 1 1 1 1 1 [5,] 1 0 1 0 1 [6,] 0 1 0 1 1 . test = function(a) prod(a)==1 rslt = c() for (i in 1:1000){ rslt[i] = test(mat[i,]) } sum(rslt) . [1] 334 . (&#54400;&#51060;6) . - 숫자로 만들고 보니까 베르누이로 뽑아도 괜찮을 것 같다. . rbinom(5,size=1,prob=0.8) # 하나의행 . [1] 1 1 1 1 1 . set을 만들 필요가 없음 | . mat = rbinom(1000*5,size=1,prob=0.8) dim(mat)=c(1000,5) head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] 1 1 1 1 0 [2,] 1 1 1 1 1 [3,] 1 1 1 1 1 [4,] 1 1 0 1 1 [5,] 1 1 1 1 0 [6,] 1 1 1 1 1 . test = function(a) prod(a)==1 rslt = c() for (i in 1:1000){ rslt[i] = test(mat[i,]) } sum(rslt) . [1] 341 . (&#54400;&#51060;7) . - 매트릭스 옆에 결과를 붙여보자. . mat = rbinom(1000*5,size=1,prob=0.8) dim(mat)=c(1000,5) head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] 1 1 1 1 1 [2,] 1 0 1 1 1 [3,] 1 1 1 0 1 [4,] 1 1 0 0 1 [5,] 1 0 0 1 0 [6,] 0 1 1 0 1 . test = function(a) prod(a)==1 rslt = c() for (i in 1:1000){ rslt[i] = test(mat[i,]) } . cbind(mat,rslt)[1:20,] . rslt [1,] 1 1 1 1 1 1 [2,] 1 0 1 1 1 0 [3,] 1 1 1 0 1 0 [4,] 1 1 0 0 1 0 [5,] 1 0 0 1 0 0 [6,] 0 1 1 0 1 0 [7,] 1 1 0 0 1 0 [8,] 0 1 1 1 1 0 [9,] 1 1 1 1 1 1 [10,] 0 1 1 0 1 0 [11,] 1 1 1 0 1 0 [12,] 0 1 1 1 0 0 [13,] 1 1 1 1 1 1 [14,] 1 1 1 0 0 0 [15,] 1 1 1 1 1 1 [16,] 1 1 1 1 1 1 [17,] 1 1 1 1 1 1 [18,] 1 1 1 1 1 1 [19,] 0 1 1 1 1 0 [20,] 0 1 1 1 0 0 . (&#54400;&#51060;8) for&#47928;&#51012; &#54616;&#45208;&#46020; &#49324;&#50857;&#54616;&#51648; &#50506;&#51008; &#54400;&#51060; . - 매트릭스의 각 row에 어떠한 함수를 반복적으로 적용하는 형태임 $ to$ apply . mat = rbinom(1000*5,size=1,prob=0.8) dim(mat)=c(1000,5) head(mat) . [,1] [,2] [,3] [,4] [,5] [1,] 0 1 1 1 1 [2,] 0 1 0 1 1 [3,] 1 1 0 1 1 [4,] 1 1 1 1 1 [5,] 0 1 1 0 0 [6,] 1 1 0 1 1 . sum(apply(mat,1,test)) . [1] 331 . apply(mat,1,test) %&gt;% sum . [1] 331 . mat %&gt;% apply(1,test) %&gt;% sum . [1] 331 . (&#54400;&#51060;9) . - 바이노미알 이용: 어차피 베르누이의 합은 바이노미알이라고 했음 . sum(rbinom(1000,size=5,p=0.8)==5) . [1] 344 . &#49689;&#51228; . 징검다리 문제 . 강화유리와 유리를 랜덤으로 찍는 참가자가 2명 있다고 하자. (따라서 강화유리를 고를 확률이 50%이다.) . (강화유리, 유리)의 징검다리가 3개 있다고 하자. (따라서 총 6개의 유리가 있고, 3번연속으로 강화유리를 고르면 2명 모두 살아남는다) . 8000번의 시뮬레이션을 하였을 경우 아래의 질문에 답하라. . (질문1) 2명 모두 살아남는 경우는 몇번인가? 약 1000번 . (질문2) 1명만 살아남는 경우는 몇번정도인가? 약 3000번 정도.. . (풀이) . 질문1: 확률이 0.5인 시행을 3번하여 3번 모두 성공하는 경우 . sum(rbinom(8000,size=3,p=0.5)==3) . 1003 질문2: 확률이 0.5인 시행을 3번하여 2번 성공하는 경우 . sum(rbinom(8000,size=3,p=0.5)==2) . 3003",
            "url": "https://sempre39.github.io/econ_blog/2022/01/21/_11_23_(11%EC%A3%BC%EC%B0%A8)_11%EC%9B%9423%EC%9D%BC.html",
            "relUrl": "/2022/01/21/_11_23_(11%EC%A3%BC%EC%B0%A8)_11%EC%9B%9423%EC%9D%BC.html",
            "date": " • Jan 21, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "(11주차) 11월18일",
            "content": "&#51221;&#51201;&#48516;&#51032; &#44228;&#49328; (2007&#45380; 9&#50900; &#54217;&#44032;&#50896;) . (문제) $ int_0^2 |x^2(x-1)| dx $ 의 값은? . (1) $ frac{3}{2}$ . (2) $2$ . (3) $ frac{5}{2}$ . (4) $3$ . (5) $ frac{7}{2}$ . (풀이) . x=seq(from=0, to=2, by=0.01) y=abs(x**2 * (x-1)) . plot(x,y,type=&#39;l&#39;) . - 아이디어: (1) 가로가 2 세로가 4인 작사각형에 임의의 점을 뿌린다. (2) 전체점의 수와 함수 아래에 위치한 점의 갯수를 센다. (3) 점의 갯수를 바탕으로 넓이를 추론한다. . xx=runif(10000) # 0~1 사이의 점을 랜덤으로 10000개 뽑음 . xx = xx*2 # 0~2사이의 값을 랜덤으로 10000개 뽑은것과 같은 효과 . yy=runif(10000)*4 # 0~4 사의의 점을 랜덤으로 10000개 뽑음 . plot(xx,yy) . 가로가 2, 세로가 4인 직사각형에 무작위로 점이 흩뿌려져 있다. . plot(xx,yy) lines(x,y,col=&#39;red&#39;,lwd=3) . 붉은선 아래의 점들이 몇개일까? . test = function(xx,yy){ yy &lt; abs(xx**2 * (xx-1)) } . print(c(xx[1],yy[1])) ## xx[1], yy[1] 의 값 = 무작위로 찍힌 값 print(abs(xx[1]**2 *(xx[1]-1))) ## xx[1]에 해당하는 붉은점의 값 test(xx[1],yy[1]) . [1] 0.830618 2.372124 [1] 0.1168611 . [1] FALSE . plot(xx,yy,col=&#39;gray&#39;) lines(x,y,col=&#39;red&#39;,lwd=3) points(xx[1],yy[1],col=&#39;blue&#39;) points(xx[1],abs(xx[1]**2 * (xx[1]-1)),col=&#39;red&#39;) . tst = c() for (i in 1:10000) tst[i] = test(xx[i],yy[i]) . head(tst) . [1] FALSE FALSE FALSE FALSE FALSE FALSE . plot(xx,yy,col=&#39;gray&#39;) lines(x,y,col=&#39;red&#39;,lwd=3) points(xx[tst],yy[tst],col=&#39;red&#39;) . 붉은점들의 갯수는? tst==TRUE인 점들의 수 . sum(tst) . [1] 1829 . 전체 10000개 중에서 1829개정도가 붉은점임. 따라서 . $$ frac{s}{8} approx frac{1829}{10000}$$ . 이므로 구하는 넓이는 대략적으로 . 1829/10000 * 8 . [1] 1.4632 . 따라서 답은 1번 3/2 이다. . - 이와 같은 방법을 몬테카를로 방법이라고 한다. . - 꽤 복잡한 함수에 대하여서도 정적분의 값을 근사적으로 계산해낼 수 있다는 장점이 있음. . (풀이2) . - 사실 그냥 아래와 같이 풀어도 된다. . sum(yy &lt; abs(xx^2 * (xx-1)) ) . [1] 1829 . &#47004;&#45924;&#48320;&#49688; . &#47004;&#45924;&#48320;&#49688;&#47484; &#49373;&#49457;&#54616;&#45716; &#48169;&#48277; . &#50696;&#51228;1: &#44512;&#46321;&#48516;&#54252; . - 목표: 구간 [0,1]에서 하나의 임의의 값을 뽑는것 (이때 구간 [0,1]에서 각 점이 뽑힐 확률은 동일) . runif(1) . [1] 0.7638336 . - 목표: 구간 [0,1]에서 10개의 값을 뽑고 싶다면? . runif(10) . [1] 0.43916197 0.58808151 0.01061738 0.57311258 0.62008149 0.79359762 [7] 0.43567517 0.06111325 0.66865770 0.98463477 . - 10000개의 값을 뽑아보고 평균이 0.5근처인지 체크해보자. . runif(10000) %&gt;% mean . [1] 0.5001962 . &#50696;&#51228;2: &#44512;&#46321;&#48516;&#54252; . - 목표: 구간 [0,2]에서 하나의 값을 임의로 뽑고 싶다. (이때 구간 [0,2]에서 각 점이 뽑힐 확률은 동일) . - 방법1 . runif(n=1,min=0,max=2) . [1] 0.7713044 . - 방법2 . runif(1)*2 . [1] 1.197119 . 왜 방법2처럼 해도되는가? $X sim U(0,1)$ 이면 $2X sim U(0,2)$ 이므로 | 이론적인 내용은 수리통계학에서 배울것임 | . - 10000개의 값을 뽑아보고 평균이 1인지 살펴보자. . runif(n=10000,min=0,max=2) %&gt;% mean . [1] 0.9979827 . (runif(10000)*2) %&gt;% mean . [1] 0.9942539 . &#50696;&#51228;3: &#48288;&#47476;&#45572;&#51060;&#48516;&#54252; ($n=1$&#51064; &#51060;&#54637;&#48516;&#54252;) . - 목표: 동전을 한번 던져서 앞면이 나오는 경우를 생성하고 싶음 (이때 동전은 공평한 동전이라 가정하자. 즉 앞면이 나올 횟수와 뒷면이 나올 횟수는 같다고 하자.) . rbinom(1,size=1,prob=0.5) . [1] 0 . 앞면이 1, 뒷면이 0이라고 생각 | . - 잘 되는것이 맞는지 한번 체크해보자. (10000개 정도의 동전을 던져서 결과를 저장하고 평균이 0.5인지 체크하자) . rbinom(10000,size=1,prob=0.5) %&gt;% mean . [1] 0.5022 . - 동전이 공평하지 않다고 하자. 예를들어 앞면이 나올 확률이 0.8이라고 생각하자. . rbinom(10000,size=1,prob=0.8) %&gt;% mean . [1] 0.8083 . &#50696;&#51228;4: &#51060;&#54637;&#48516;&#54252; . - 목표: 동전을 10회던져 앞면이 나올 총 횟수를 생성하자. . 동전을 10회던져 앞면이 나온 횟수를 $X$라고 하자. $X$를 생성하라. | . rbinom(1,size=10,prob=0.5) . [1] 3 . - 평균적으로 5가 나와야 한다. (10000번 정도 뽑아보고 관찰하자) . rbinom(10000,size=10,prob=0.5) %&gt;% mean . [1] 5.0029 . - 베르누이 분포는 이항분포의 특수한 경우이다. . - 직관적으로 생각하면 아래와 같이 이항분포를 생성해도 될 것 같다. . rbinom(10,size=1,prob=0.5) %&gt;% sum . [1] 4 . X=c() for (i in 1:10000) X[i] = rbinom(10,size=1,prob=0.5) %&gt;% sum . X . [1] 6 5 7 2 2 5 4 5 5 2 3 5 5 4 5 5 4 6 5 5 3 3 5 3 [25] 5 3 9 4 8 3 3 5 5 3 6 4 7 4 7 6 6 4 5 5 7 3 5 2 [49] 6 5 5 5 4 6 8 5 2 4 4 6 6 4 7 5 4 1 4 5 7 7 4 5 [73] 4 5 4 7 4 4 3 4 6 6 5 4 6 5 5 5 6 4 5 6 4 4 8 6 [97] 5 5 3 8 4 4 5 2 4 3 2 3 5 4 5 7 4 4 9 5 4 5 5 5 [121] 7 4 6 6 6 5 3 5 7 6 7 4 3 6 4 3 4 6 5 6 6 5 6 9 [145] 4 6 10 2 6 3 7 3 6 2 2 5 6 6 5 3 3 5 5 7 5 5 5 5 [169] 6 3 5 6 3 6 3 6 4 6 5 5 4 5 6 3 5 6 3 5 6 6 4 7 [193] 5 4 3 8 5 5 5 4 7 5 5 5 5 4 6 6 5 4 3 10 5 4 5 4 [217] 4 5 4 9 4 5 3 4 4 3 5 3 4 4 5 7 3 4 6 5 8 5 4 3 [241] 5 4 4 6 7 5 7 5 4 8 3 6 5 5 3 5 5 3 2 5 5 4 6 6 [265] 6 4 6 5 3 3 6 6 5 5 4 5 5 4 7 6 5 4 3 4 4 4 5 5 [289] 3 6 6 3 6 4 6 7 4 6 3 4 5 3 5 3 5 7 4 2 6 4 5 4 [313] 5 7 8 1 7 4 5 8 5 3 6 6 6 7 5 8 4 6 6 6 4 6 3 6 [337] 5 4 5 6 8 7 3 5 6 6 5 5 4 3 8 4 6 4 3 2 5 8 5 6 [361] 2 4 5 5 5 5 6 5 4 5 4 4 2 6 5 7 3 3 6 6 9 6 4 6 [385] 4 5 8 4 7 5 6 5 5 8 6 4 5 3 6 6 5 7 6 8 3 3 6 7 [409] 8 5 5 5 6 6 5 4 6 3 4 4 5 5 6 6 5 5 8 4 5 6 2 4 [433] 3 1 4 6 7 5 3 5 9 8 5 6 2 4 5 5 6 6 5 5 7 6 6 4 [457] 7 4 4 7 7 2 3 7 3 7 4 5 6 4 4 4 5 7 2 4 8 7 6 6 [481] 5 4 4 6 5 5 3 7 2 3 8 4 4 3 5 3 6 4 6 6 5 4 4 7 [505] 3 6 3 5 2 3 4 5 6 4 3 4 7 5 7 6 4 6 7 2 6 8 5 2 [529] 7 5 3 8 7 6 5 3 6 5 7 2 6 3 5 5 3 4 6 2 2 4 6 3 [553] 5 6 8 4 4 7 5 6 2 8 7 5 6 5 1 7 7 2 5 4 5 7 4 6 [577] 7 3 6 7 6 4 4 7 5 5 5 5 4 1 5 5 5 5 6 1 5 2 3 2 [601] 3 5 6 0 5 4 3 5 6 2 5 3 5 6 6 6 2 4 4 4 3 5 7 5 [625] 4 6 4 9 4 7 4 5 7 8 6 5 5 6 7 3 4 4 4 5 6 5 6 3 [649] 6 7 5 5 3 4 5 3 4 6 3 4 3 7 3 5 6 6 5 6 6 3 3 5 [673] 6 4 2 6 6 6 6 4 5 5 5 3 7 4 6 3 4 6 6 7 3 1 8 1 [697] 7 6 8 7 4 7 3 3 3 4 3 8 4 4 6 3 6 2 2 5 3 5 8 6 [721] 2 6 5 7 6 5 7 4 7 6 3 5 4 4 6 7 5 6 4 5 4 4 6 5 [745] 4 7 6 5 6 7 5 7 2 5 2 5 3 6 5 7 7 6 4 3 2 1 9 6 [769] 5 6 4 8 6 5 4 5 5 3 5 3 5 6 8 5 5 6 2 5 3 5 3 4 [793] 4 5 5 4 4 6 4 4 4 5 5 5 6 7 5 3 7 6 5 7 7 5 6 7 [817] 3 6 4 3 6 5 6 3 7 5 6 6 6 6 4 7 6 5 3 3 6 5 3 5 [841] 5 6 5 4 6 6 5 6 5 4 5 6 3 4 5 5 4 8 3 6 4 5 6 8 [865] 5 6 9 5 7 7 4 4 6 7 4 5 6 4 4 5 6 6 4 5 2 5 6 3 [889] 5 5 5 5 3 5 5 7 3 6 6 7 5 2 5 5 8 4 3 4 6 6 3 5 [913] 7 7 5 6 5 6 4 3 7 4 9 9 7 4 3 6 4 3 4 3 5 6 5 4 [937] 5 5 4 4 2 3 4 7 6 6 4 5 5 7 5 8 6 8 5 5 6 6 4 6 [961] 6 2 5 8 8 5 7 6 6 7 7 8 3 5 3 4 6 6 6 5 7 3 6 4 [985] 1 5 5 2 4 7 4 8 5 6 3 5 4 6 6 5 [ reached getOption(&#34;max.print&#34;) -- omitted 9000 entries ] . 직관적으로 생각하면 X는 rbinom(10000,size=10,prob=0.5) 와 같은 효과 (랜덤성 때문에 같은 값은 아님) 일 것 같은데 이는 실제로 그러하다. (좀 더 엄밀한 증명은 수리통계 시간에 배운다) | . X %&gt;% mean() . [1] 5.0216 . &#50612;&#46496;&#54620; &#51665;&#54633;&#50640;&#49436; &#49368;&#54540;&#47553; . &#50696;&#51228;5: &#48708;&#48373;&#50896;&#52628;&#52636; . - 주머니에서 빨간공 2개와 파란공 3개가 있다고 하자. . set = c(rep(&quot;red&quot;,2),rep(&quot;blue&quot;,3)) set . [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; . - 이러한 집합에서 랜덤으로 3개의 원소를 고르고 싶다면? (단, 뽑은 공은 다시 넣지 않는다) . sample(set,size=3) . [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; . - 50번정도 해보자. . for (i in 1:50) sample(set,size=3) %&gt;% print . [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; . 빨간공을 3번 뽑지는 못함 | . &#50696;&#51228;6: &#48373;&#50896;&#52628;&#52636; . - 뽑은공을 다시 넣는다고 가정한다면? . set = c(rep(&quot;red&quot;,2),rep(&quot;blue&quot;,3)) set . [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; . for (i in 1:50) sample(set, size=3,replace = TRUE) %&gt;% print . [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;red&#34; [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; [1] &#34;red&#34; &#34;red&#34; &#34;blue&#34; [1] &#34;blue&#34; &#34;blue&#34; &#34;blue&#34; . 빨간공을 3번 뽑을 수 있음 | . (&#51064;&#45937;&#49828;,&#54869;&#47456;) &#51221;&#48372;&#44032; &#51452;&#50612;&#51276;&#51012; &#44221;&#50864; &#49368;&#54540;&#47553; . &#50696;&#51228;7: &#50696;&#51228;6&#51032; &#45796;&#47480;&#44396;&#54788; . - 예제6의 코드는 아래와 같다. . set = c(&#39;red&#39;,&#39;blue&#39;) ## 인덱스.. p = c(0.4,0.6) ## 인덱스에 해당하는 확률 . sample(set,size=3, prob=p, replace = T) . [1] &#34;red&#34; &#34;blue&#34; &#34;blue&#34; . - 아래와 같은 코드로도 응용가능하다. . sample(set,size=20,prob=c(0.95,0.05),replace=T) . [1] &#34;blue&#34; &#34;blue&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; [11] &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; &#34;red&#34; . &#51204;&#52404;&#51665;&#54633;&#50640;&#49436; &#49436;&#47196; &#45796;&#47480; &#54869;&#47456;&#47196; &#50896;&#49548;&#44032; &#48977;&#55176;&#45716; &#44221;&#50864; . &#50696;&#51228;8 . - 예제7의 코드에서 replace를 제외한다면? . set = c(&#39;red&#39;,&#39;blue&#39;) ## 인덱스.. . sample(set,size=20,prob=c(0.95,0.05)) . Error in sample.int(length(x), size, replace, prob): cannot take a sample larger than the population when &#39;replace = FALSE&#39; Traceback: 1. sample(set, size = 20, prob = c(0.95, 0.05)) 2. sample.int(length(x), size, replace, prob) . 당연히 에러가남 (원소가 2개 있는 set에서 20개를 뽑으라고 하니..) | . - 아래는 에러가 나지 않을 것임 . sample(set,size=2,prob=c(0.95,0.05)) . [1] &#34;red&#34; &#34;blue&#34; . - 의미는? . rslt = matrix(rep(&quot;-&quot;,1000*2),ncol=2) head(rslt) . [,1] [,2] [1,] - - [2,] - - [3,] - - [4,] - - [5,] - - [6,] - - . for (i in 1:1000) rslt[i,] = sample(set,size=2,prob=c(0.95,0.05)) . head(rslt) . [,1] [,2] [1,] red blue [2,] red blue [3,] red blue [4,] red blue [5,] red blue [6,] red blue . sum(rslt[,1]==&#39;red&#39;)/1000 . [1] 0.947 . 대략 95% | . - 첫번째가 붉은 공이 뽑힐 확률은 95%임. 그리고 두번째 공은 첫번째 공과 다른색이 뽑힘 . &#49689;&#51228;: &#51669;&#44160;&#45796;&#47532; &#44148;&#45320;&#44592; . (유리,강화유리)의 쌍으로 이루어진 징검다리가 총 5개 있다고 하자. (따라서 징검다리는 모두 10개이다) . 강화유리로 된 징검다리를 밟으면 살아남지만 유리로 된 징검다리를 밟으면 죽는다. . 따라서 강화유리로 된 징검다리를 계속 골라야 살아남을 수 있다. . A씨는 유리공장에서 20년 근무한 장인으로 유리와 강화유리를 구분할수 있는 능력을 가졌다고 하자. . 그래서 강화유리로 된 징검다리를 고를 확률이 80%라고 하자. . A씨가 살아남을 확률을 시뮬레이션을 통하여 구하여라. . Hint: 총 1000번의 시뮬레이션을 수행하고 그중에서 A씨가 살아남는 케이스가 몇회정도 되는지 찾아라. . sample = rbinom(1000,size=5,prob=0.8) sample . &lt;ol class=list-inline&gt;4 | 5 | 5 | 5 | 5 | 4 | 5 | 3 | 4 | 5 | 4 | 2 | 3 | 4 | 5 | 5 | 4 | 5 | 5 | 4 | 4 | 4 | 3 | 5 | 4 | 5 | 3 | 5 | 4 | 4 | 5 | 5 | 4 | 5 | 5 | 3 | 4 | 2 | 5 | 5 | 4 | 3 | 2 | 4 | 5 | 2 | 5 | 3 | 3 | 4 | 5 | 5 | 5 | 5 | 3 | 5 | 3 | 5 | 4 | 5 | 5 | 3 | 4 | 4 | 5 | 4 | 5 | 5 | 5 | 4 | 4 | 4 | 4 | 4 | 3 | 4 | 3 | 3 | 5 | 3 | 4 | 4 | 5 | 4 | 3 | 4 | 4 | 4 | 4 | 4 | 3 | 3 | 4 | 5 | 4 | 4 | 5 | 4 | 3 | 5 | 5 | 5 | 3 | 5 | 3 | 5 | 5 | 5 | 3 | 2 | 4 | 5 | 4 | 5 | 4 | 4 | 4 | 3 | 3 | 5 | 2 | 4 | 4 | 5 | 3 | 5 | 5 | 5 | 5 | 3 | 3 | 4 | 3 | 3 | 5 | 4 | 2 | 5 | 4 | 4 | 5 | 5 | 5 | 3 | 4 | 4 | 4 | 3 | 4 | 4 | 5 | 4 | 4 | 4 | 3 | 4 | 5 | 4 | 4 | 4 | 5 | 3 | 5 | 3 | 4 | 4 | 4 | 5 | 5 | 5 | 5 | 5 | 3 | 4 | 5 | 3 | 5 | 4 | 4 | 4 | 3 | 4 | 2 | 5 | 4 | 4 | 5 | 3 | 5 | 4 | 4 | 2 | 4 | 5 | 5 | 5 | 4 | 2 | 5 | 4 | ⋯ | 4 | 3 | 2 | 4 | 4 | 5 | 5 | 5 | 4 | 5 | 3 | 4 | 4 | 4 | 3 | 5 | 5 | 2 | 4 | 4 | 3 | 5 | 1 | 4 | 4 | 2 | 5 | 5 | 5 | 2 | 4 | 3 | 4 | 5 | 2 | 3 | 5 | 4 | 5 | 3 | 4 | 4 | 3 | 5 | 4 | 4 | 4 | 2 | 3 | 5 | 4 | 2 | 3 | 4 | 3 | 5 | 3 | 5 | 3 | 5 | 3 | 4 | 5 | 5 | 4 | 5 | 5 | 3 | 4 | 4 | 3 | 4 | 5 | 5 | 4 | 3 | 3 | 4 | 4 | 4 | 3 | 5 | 4 | 5 | 5 | 5 | 4 | 4 | 4 | 3 | 4 | 4 | 5 | 4 | 5 | 5 | 4 | 3 | 4 | 4 | 3 | 4 | 5 | 4 | 5 | 4 | 3 | 4 | 3 | 2 | 5 | 2 | 3 | 4 | 3 | 3 | 4 | 5 | 3 | 4 | 4 | 5 | 5 | 4 | 4 | 4 | 5 | 4 | 4 | 3 | 5 | 3 | 4 | 5 | 5 | 3 | 3 | 4 | 4 | 4 | 3 | 3 | 5 | 3 | 5 | 4 | 3 | 4 | 4 | 2 | 3 | 4 | 5 | 4 | 3 | 4 | 5 | 4 | 5 | 4 | 4 | 4 | 5 | 3 | 4 | 5 | 3 | 3 | 4 | 5 | 4 | 3 | 4 | 5 | 4 | 5 | 4 | 5 | 4 | 3 | 2 | 3 | 5 | 4 | 4 | 5 | 4 | 5 | 3 | 4 | 5 | 4 | 4 | 5 | 5 | 4 | 4 | 5 | 4 | 5 | &lt;/ol&gt; X &lt;- sample == 5 X . &lt;ol class=list-inline&gt;FALSE | TRUE | TRUE | TRUE | TRUE | FALSE | TRUE | FALSE | FALSE | TRUE | FALSE | FALSE | FALSE | FALSE | TRUE | TRUE | FALSE | TRUE | TRUE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | TRUE | FALSE | TRUE | FALSE | FALSE | TRUE | TRUE | FALSE | TRUE | TRUE | FALSE | FALSE | FALSE | TRUE | TRUE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | TRUE | FALSE | FALSE | FALSE | TRUE | TRUE | TRUE | TRUE | FALSE | TRUE | FALSE | TRUE | FALSE | TRUE | TRUE | FALSE | FALSE | FALSE | TRUE | FALSE | TRUE | TRUE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | TRUE | FALSE | FALSE | TRUE | TRUE | TRUE | FALSE | TRUE | FALSE | TRUE | TRUE | TRUE | FALSE | FALSE | FALSE | TRUE | FALSE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | FALSE | TRUE | FALSE | TRUE | TRUE | TRUE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | TRUE | FALSE | FALSE | TRUE | TRUE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | FALSE | TRUE | FALSE | TRUE | FALSE | FALSE | FALSE | FALSE | TRUE | TRUE | TRUE | TRUE | TRUE | FALSE | FALSE | TRUE | FALSE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | TRUE | FALSE | TRUE | FALSE | FALSE | FALSE | FALSE | TRUE | TRUE | TRUE | FALSE | FALSE | TRUE | FALSE | ⋯ | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | TRUE | TRUE | FALSE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | TRUE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | FALSE | FALSE | TRUE | TRUE | TRUE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | TRUE | FALSE | TRUE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | TRUE | FALSE | TRUE | FALSE | FALSE | TRUE | TRUE | FALSE | TRUE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | TRUE | TRUE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | TRUE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | FALSE | TRUE | TRUE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | TRUE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | TRUE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | FALSE | TRUE | FALSE | TRUE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | TRUE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | FALSE | TRUE | FALSE | TRUE | FALSE | TRUE | FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | FALSE | TRUE | FALSE | TRUE | FALSE | FALSE | TRUE | FALSE | FALSE | TRUE | TRUE | FALSE | FALSE | TRUE | FALSE | TRUE | &lt;/ol&gt; sum(X)/1000*100 . 32.4",
            "url": "https://sempre39.github.io/econ_blog/2022/01/21/_11_18_(11%EC%A3%BC%EC%B0%A8)_11%EC%9B%9418%EC%9D%BC.html",
            "relUrl": "/2022/01/21/_11_18_(11%EC%A3%BC%EC%B0%A8)_11%EC%9B%9418%EC%9D%BC.html",
            "date": " • Jan 21, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "(10주차) 11월16일",
            "content": "options(jupyter.rich_display=FALSE) . &#47532;&#49828;&#53944; . - 이상한 자료형 . - 제가 굉장히 많이 사용하는 자료형태.. 그런데 왜 쓰는지 이유를 물어보면 딱히 잘 모르겠어요 . &#50696;&#51228;1 . - 리스트를 선언하는 방법 . lst = list(5:10,c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;),matrix(c(T,T,F,T),ncol=2)) . lst . [[1]] [1] 5 6 7 8 9 10 [[2]] [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; [[3]] [,1] [,2] [1,] TRUE FALSE [2,] TRUE TRUE . 리스트의 첫번째 원소 = 숫자로 이루어진 벡터 | 리스트의 두번째 원소 = 문자로 이루어진 벡터 | 리스트의 세번째 원소 = True / False로 이루어진 매트릭스 | . - 리스트의 각 원소를 추출하는 방법 . lst[[1]] . [1] 5 6 7 8 9 10 . lst[[2]] . [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; . lst[[3]] . [,1] [,2] [1,] TRUE FALSE [2,] TRUE TRUE . lst[[1]]+3 . [1] 8 9 10 11 12 13 . - 리스트의 길이 . length(lst) . [1] 3 . - 왜 리스트를 쓰는가? (1) 함수에서 여러개의 리턴값을 주는 효과 (2) 정리의 효과 . 명확한 이점: 함수의 리턴값을 여러개 | 그외의 이점: 저도 솔직히 잘 모르겠어요. | 벡터, 매트릭스, 데이터프레임와 같이 기능상의 이점이 있는것 같진 않아요. | 그런데 자료를 저장하고 정리하기에 좋아요 (제가 정리하는걸 좋아하는것 같아요) | . &#50696;&#51228;2 . mid = list(c(&#39;hynn&#39;,&#39;iu&#39;,&#39;gd&#39;),c(100,95,100)) mid . [[1]] [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; [[2]] [1] 100 95 100 . names(mid) . NULL . names(mid)&lt;-c(&#39;names&#39;,&#39;score&#39;) . mid . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $score [1] 100 95 100 . - 보기에 깔끔하다. . - 데이터에 접근하기도 좋다. . mid$names . [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; . mid$score . [1] 100 95 100 . - 물론 아래와 같이 접근할수도 있다. . mid[[1]] . [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; . mid[[2]] . [1] 100 95 100 . - 리스트를 복사후 재생성하기에 좋음 . mid . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $score [1] 100 95 100 . final = mid . final . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $score [1] 100 95 100 . final$score = mid$score - 10 . final$score . [1] 90 85 90 . final . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $score [1] 90 85 90 . - 리스트를 묶어서 새로운 리스트를 또 만들 수도 있음 . IR2021 &lt;- list(mid,final) . IR2021 . [[1]] [[1]]$names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; [[1]]$score [1] 100 95 100 [[2]] [[2]]$names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; [[2]]$score [1] 90 85 90 . - 리스트원소에 이름을 붙여주면 . names(IR2021) . NULL . names(IR2021) &lt;- c(&quot;mid&quot;,&quot;final&quot;) . IR2021 . $mid $mid$names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $mid$score [1] 100 95 100 $final $final$names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $final$score [1] 90 85 90 . IR2021$final$score . [1] 90 85 90 . - 아래와 같이 선언하는 것도 깔끔해보인다. . IR2021 = list(names=mid$names, mid=mid$score, final=final$score) # 리스트의 구성요소와 이름을 동시에 선언 IR2021 . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $mid [1] 100 95 100 $final [1] 90 85 90 . &#47532;&#49828;&#53944;&#51032; &#49436;&#48652;&#49483;&#54021; . IR2021 . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $mid [1] 100 95 100 $final [1] 90 85 90 . [&#50672;&#49328;&#51088;: &#47532;&#49828;&#53944;&#47484; &#47532;&#53556; . IR2021[1] . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; . IR2021[1:2] . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $mid [1] 100 95 100 . IR2021[c(1,3)] . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $final [1] 90 85 90 . IR2021[-2] . $names [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; $final [1] 90 85 90 . [[ &#50672;&#49328;&#51088;: &#47532;&#49828;&#53944;&#51032; &#50836;&#49548;&#47484; &#52628;&#52636;&#54632; . IR2021[[1]] . [1] &#34;hynn&#34; &#34;iu&#34; &#34;gd&#34; . IR2021[[2]] . [1] 100 95 100 . - 아래는 동작하지 않음 . IR2021[[-1]] . Error in IR2021[[-1]]: invalid negative subscript in get1index &lt;real&gt; Traceback: . - 아래는 의도와 다르게 동작함 . IR2021[[1:2]] . IR2021[[c(1,2)]] . IR2021[[1]][2]와 결과가 같음 | . IR2021[[1:3]] . IR2021[[c(1,3)]] #IR2021[[1]][3] . $&#50672;&#49328;&#51088; . IR2021$names . [[&#39;names&#39;]]&#50752; &#44057;&#51008; &#49324;&#50857;&#46020; &#44032;&#45733; . IR2021[[&#39;names&#39;]] . - 언뜻 생각하면 IR2021$names 와 IR2021[[&#39;names&#39;]] 의 기능은 같으므로 이 경우에는 $와 [[를 서로 바꿔도 될것 같다. 하지만 항상 그런 것은 아니다. . IR2021$n . IR2021[[&#39;n&#39;]] . - 즉 $연산자와 [[연산자의 차이는 파샬매칭(partial matching)을 허용하느냐 하지않느냐의 차이다. . IR2021$n . IR2021$na . IR2021$name . 특히 마지막 IR2021$name은 마치 오타를 허용해주는 느낌이다. | . - 그런데 아래는 동작하지 않음 . IR2021$ames . IR2021$es . &#47532;&#49828;&#53944;&#51032; &#51025;&#50857;: &#54632;&#49688;&#51032; return&#51004;&#47196; &#49324;&#50857; . - R에서는 일반적으로 하나의 오브젝트만 리턴함 . - 하지만 리스트를 사용하면 다중리턴을 지원하는 것처럼 느낄 수 있음. . cal= function(x,y){ return(list(add=x+y, sub=x-y, mul=x*y, dic=x/y)) } . cal(2,3) . - 이런일이 있으면 그냥 cal_add, cal_mul, cal_sub, cal_div 처럼 함수를 4개 구현하면 되는것이 아닌가? $ to$ 물론 그래도 가능하지만 코드가 지저분해 지니까 . - 함수의 결과값을 저장하여 아래와 같이 사용 . rslt = cal(4,3) . rslt$add . rslt$sub . - 아래와 같이 쓰지는 않음 . cal(4,3)$add . cal(4,3)$sub . &#49689;&#51228; . - 기본적인 자료형 vector, matrix, list에 기능을 스스로 정리해보고 요약해볼것 (제출의무 없음) . 벡터의 길이를 재려면 어떻게 해야하는지? | 매트릭스의 차원은 어떻게 알 수 있는지? | 리스트의 원소에 접근하려면? | $n times 1$ 매트릭스 혹은 $1 times n$ 매트릭스를 쓰면 되는데 왜 굳이 벡터를 만들었을까? | . - 벡터 ${ bf x}$와 벡터 ${ bf y}$를 아래의 코드를 이용해 표준 정규분포에서 생성하라. (표준정규분포를 모른다면 질문하거나 네이버 구글에서 스스로 찾아볼것) . x=rnorm(100) y=rnorm(100) . 아래의 수식을 계산하는 코드를 작성하라. . $$ frac{ sum_{i=1}^{100}(x_i- bar{x})(y_i- bar{y})}{ sqrt{ sum_{i=1}^{100}(x_i- bar{x})^2} sqrt{ sum_{i=1}^{100}(y_i- bar{y})^2}}$$ . 단 $ bar{x}= frac{1}{100} sum_{i=1}^{100}x_i$로 정의한다. . x=rnorm(100) y=rnorm(100) . num &lt;- sum((x-mean(x))*(y-mean(y))) num . [1] 6.206896 . den &lt;- sqrt(sum((x-mean(x))^2))*sqrt(sum((y-mean(y))^2)) den . [1] 122.7962 . normal &lt;- num/den normal . [1] 0.05054633 . . 보충학습 . x . ${ bf x} = (x_1,x_2, dots, x_{100})=(-1.34195186 ,-0.85612995, dots, -0.87349548)$ . $ frac{1}{100} sum_{i=1}^{100} x_i = frac{1}{100}(x_1+x_2+ dots +x_{100})= frac{1}{100}(-1.34195186 + (-0.85612995) + dots (-0.87349548))$ . 코드상으로는 아래와 같이 계산할 수 있겠음 . sum(x)/100 # xbar . mean(x) . . (풀이) . $$ frac{ sum_{i=1}^{100}(x_i- bar{x})(y_i- bar{y})}{ sqrt{ sum_{i=1}^{100}(x_i- bar{x})^2} sqrt{ sum_{i=1}^{100}(y_i- bar{y})^2}}= frac{A}{BC}$$ . A=0 for (i in 1:100) A=A+(x[i]-mean(x))*(y[i]-mean(y)) A . [1] 6.206896 . B=0 for (i in 1:100) B=B+(x[i]-mean(x))**2 B=sqrt(B) B . [1] 11.24123 . C=0 for (i in 1:100) C=C+(y[i]-mean(y))**2 C=sqrt(C) C . [1] 10.92373 . A/(B*C) . [1] 0.05054633 . (다른풀이) . sum((x-mean(x))*(y-mean(y))) / (sqrt(sum((x-mean(x))**2)) * sqrt(sum((y-mean(y))**2))) . (다른풀이2) . 벡터의 내적: ${ bf x}=(x_1, dots,x_{100})$ 라고 하고, ${ bf y}=(y_1, dots,y_{100})$ 라고 할때 두 벡터의 내적은 아래와 같이 계산한다. . $${ bf x} cdot { bf y} = x_1 y_1 + dots + x_{100}y_{100}$$ . x_ &lt;- c(1,2,3) y_ &lt;- c(2,3,4) . x_ %*% y_ . 1*2+ 2*3+ 3*4 . 이러한 성질을 이용하면 . xx= x-mean(x) yy= y-mean(y) . ((xx %*% yy) / (sqrt(xx %*% xx )* sqrt(yy %*% yy ))) . Error in eval(expr, envir, enclos): 객체 &#39;xx&#39;를 찾을 수 없습니다 Traceback: .",
            "url": "https://sempre39.github.io/econ_blog/2022/01/21/_11_16_(10%EC%A3%BC%EC%B0%A8)_11%EC%9B%9416%EC%9D%BC.html",
            "relUrl": "/2022/01/21/_11_16_(10%EC%A3%BC%EC%B0%A8)_11%EC%9B%9416%EC%9D%BC.html",
            "date": " • Jan 21, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "2021년 1학기 R입문 중간고사",
            "content": "1. R&#51012; &#51060;&#50857;&#54616;&#50668; &#45796;&#51020;&#51012; &#44228;&#49328;&#54616;&#50668;&#46972;. (3&#51216;) . (a) $2^{-5}+2^{3}$ . 2^(-5) + 2^2 . [1] 4.03125 . (b) $ sqrt{33}$ . sqrt(33) . [1] 5.744563 . (c) $ sum_{k=1}^{100} frac{1}{k^2+2k+1}$ . k = c(1:100) sum(1/(k^2+2*k+1)) . [1] 0.6350819 . 2. &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (2&#51216;) . (a) &#50500;&#47000;&#50752; &#44057;&#51008; &#49688;&#50676;&#51012; &#49373;&#49457;&#54616;&#46972;. . $$x=(-10,-9.5,-9.0,...,9.0,9.5,10)$$ . (b) &#49373;&#49457;&#46108; &#49688;&#50676;&#50640; &#45824;&#54616;&#50668; &#50500;&#47000;&#47484; &#47564;&#51313;&#54616;&#45716; $y$&#47484; &#44228;&#49328;&#54616;&#46972;. . $$y= begin{cases} x &amp; |x|&gt;5 0 &amp; |x| leq 2 5 &amp; o.w. end{cases}$$ (a) . x &lt;- c(seq(-10,10,0.5)) x . [1] -10.0 -9.5 -9.0 -8.5 -8.0 -7.5 -7.0 -6.5 -6.0 -5.5 -5.0 -4.5 [13] -4.0 -3.5 -3.0 -2.5 -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 [25] 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 [37] 8.0 8.5 9.0 9.5 10.0 . (b) . ifelse(abs(x)&gt;5,x, ifelse(abs(x)&lt;=2,0,5)) . [1] -10.0 -9.5 -9.0 -8.5 -8.0 -7.5 -7.0 -6.5 -6.0 -5.5 5.0 5.0 [13] 5.0 5.0 5.0 5.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 [25] 0.0 5.0 5.0 5.0 5.0 5.0 5.0 5.5 6.0 6.5 7.0 7.5 [37] 8.0 8.5 9.0 9.5 10.0 . 3. $x=(-10,-9,-8, dots,8,9,10)$&#50640; &#45824;&#54616;&#50668; $h(g(f(x)))$&#51032; &#44228;&#49328;&#44208;&#44284;&#47484; &#44396;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. (10&#51216;) . 단, $f(x)$,$g(x)$, $h(x)$의 정의는 각각 아래와 같다. . $f(x)=2x+3 $ | $g(x)= frac{e^x}{1+e^x}$ | $h(x)=max(x,0)$ | . library(tidyverse) . Warning message: “package ‘tidyverse’ was built under R version 4.0.3” ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ── ✔ ggplot2 3.3.5 ✔ purrr 0.3.4 ✔ tibble 3.1.6 ✔ dplyr 1.0.7 ✔ tidyr 1.1.4 ✔ stringr 1.4.0 ✔ readr 2.1.1 ✔ forcats 0.5.1 Warning message: “package ‘ggplot2’ was built under R version 4.0.5” Warning message: “package ‘tibble’ was built under R version 4.0.5” Warning message: “package ‘tidyr’ was built under R version 4.0.5” Warning message: “package ‘readr’ was built under R version 4.0.5” Warning message: “package ‘purrr’ was built under R version 4.0.3” Warning message: “package ‘dplyr’ was built under R version 4.0.5” Warning message: “package ‘stringr’ was built under R version 4.0.5” Warning message: “package ‘forcats’ was built under R version 4.0.3” ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ✖ dplyr::filter() masks stats::filter() ✖ dplyr::lag() masks stats::lag() . x = c() f &lt;- function(x) 2*x + 3 g &lt;- function(x) exp(x)/(1+exp(x)) h &lt;- function(x) ifelse(x&gt;0,x,0) for (i in -10:10){ x = f(i) %&gt;% g %&gt;% h print(x) } . [1] 4.139938e-08 [1] 3.059022e-07 [1] 2.260324e-06 [1] 1.670142e-05 [1] 0.0001233946 [1] 0.0009110512 [1] 0.006692851 [1] 0.04742587 [1] 0.2689414 [1] 0.7310586 [1] 0.9525741 [1] 0.9933071 [1] 0.9990889 [1] 0.9998766 [1] 0.9999833 [1] 0.9999977 [1] 0.9999997 [1] 1 [1] 1 [1] 1 [1] 1 . f = function(x) 2*x +3 g = function(x) exp(x) / (1+exp(x)) h = function(x) ifelse(x&gt;0,x,0) -10:10 %&gt;% f %&gt;% g %&gt;% h . [1] 4.139938e-08 3.059022e-07 2.260324e-06 1.670142e-05 1.233946e-04 [6] 9.110512e-04 6.692851e-03 4.742587e-02 2.689414e-01 7.310586e-01 [11] 9.525741e-01 9.933071e-01 9.990889e-01 9.998766e-01 9.999833e-01 [16] 9.999977e-01 9.999997e-01 1.000000e+00 1.000000e+00 1.000000e+00 [21] 1.000000e+00 . 4. &#50500;&#47000;&#51473; &#50739;&#51008;&#44163;&#51008;? (O / X &#47196; &#45813;&#50504;&#51648;&#47484; &#50416;&#44256; &#45813;&#51032; &#44540;&#44144;&#44032; &#46104;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54624;&#44163;) (10&#51216;) . (a) $1= frac{1}{2}+ frac{1}{4} + frac{1}{8} dots $ . f = function(N){ a&lt;-c() a[1]=0.5 for(n in 2:N) a[n]=a[n-1]*0.5 sum(a) } for(k in 5:20) print (c(f(k))) . [1] 0.96875 [1] 0.984375 [1] 0.9921875 [1] 0.9960938 [1] 0.9980469 [1] 0.9990234 [1] 0.9995117 [1] 0.9997559 [1] 0.9998779 [1] 0.999939 [1] 0.9999695 [1] 0.9999847 [1] 0.9999924 [1] 0.9999962 [1] 0.9999981 [1] 0.999999 . (b) $e^x= 1+x+x^2+x^3+ dots $ . g = function(x, N){ a&lt;-c() a[1] = x for(n in 2:N) a[n]=a[n-1]*x sum(a)+1 } x=2 for (k in 5:20) print (c(exp(x)-g(x,k))) . [1] -55.61094 [1] -119.6109 [1] -247.6109 [1] -503.6109 [1] -1015.611 [1] -2039.611 [1] -4087.611 [1] -8183.611 [1] -16375.61 [1] -32759.61 [1] -65527.61 [1] -131063.6 [1] -262135.6 [1] -524279.6 [1] -1048568 [1] -2097144 . 5. &#45796;&#51020;&#51012; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (10&#51216;) . 다음은 어느 회사의 연봉에 대한 규정이다. . (가) 입사 첫째 해 연봉은 $a$원이고, 입사 19년째 해까지의 연봉은 해마다 직전 연봉에서 8%씩 인상된다. . (나) 입사 20년째 해부터의 연봉은 입사 19년째 해 연봉의 75%로 한다. . 이 회사에 입사한 사람이 28년동안 근무하여 받는 연봉의 총합은? . sal &lt;- c() sal[1] &lt;- 1 . for(i in 2:19){ sal[i] = sal[i-1]*1.08 } . sal . [1] 1.000000 1.080000 1.166400 1.259712 1.360489 1.469328 1.586874 1.713824 [9] 1.850930 1.999005 2.158925 2.331639 2.518170 2.719624 2.937194 3.172169 [17] 3.425943 3.700018 3.996019 . for (i in 20:28){ sal[i] = sal[19]*0.75 } . sal . [1] 1.000000 1.080000 1.166400 1.259712 1.360489 1.469328 1.586874 1.713824 [9] 1.850930 1.999005 2.158925 2.331639 2.518170 2.719624 2.937194 3.172169 [17] 3.425943 3.700018 3.996019 2.997015 2.997015 2.997015 2.997015 2.997015 [25] 2.997015 2.997015 2.997015 2.997015 . sum(sal) . [1] 68.41939 . 6. &#45796;&#51020; &#47928;&#51109;&#51012; &#51069;&#44256; &#52280;&#44144;&#51667;&#51012; &#54032;&#45800;&#54616;&#49884;&#50724;. (10&#51216;) . (a) _a&#45716; &#48320;&#49688;&#51060;&#47492;&#51004;&#47196; &#44032;&#45733;&#54616;&#45796;. . _a &lt;- 2 a F . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:1: 예상하지 못한 입력입니다. 1: _ ^ Traceback: . False . (b) &#48289;&#53552;&#51032; &#50896;&#49548;&#45716; &#49688;&#52824;&#54805;(numeric)&#47564; &#44032;&#45733;&#54616;&#45796;. . c &lt;- c(&#39;A&#39;, &#39;B&#39;) print (x=c) class(x=c) . [1] &#34;A&#34; &#34;B&#34; . [1] &#34;character&#34; . False . (c) &#45436;&#47532;&#54805;(logical)&#48320;&#49688;&#45716; &#49688;&#52824;&#54805; &#48320;&#49688;&#47196; &#48320;&#54872;&#54624; &#49688; &#50630;&#45796;. . d &lt;- c(F, T) print(x=d) class(x=d) d = as.numeric(d) d class(x=d) . [1] FALSE TRUE . [1] &#34;logical&#34; . [1] 0 1 . [1] &#34;numeric&#34; . True . (d) R&#50640;&#49436; {}&#45716; ()&#47196; &#48148;&#44992; &#49688; &#51080;&#45796;. . False . 7. 100&#44060;&#51032; &#46972;&#52964; (15&#51216;) . 복도에 100개의 라커가 있다. 복도를 어떤 남자가 100개의 라커 문을 전부 연다. 그리고 나서 짝수 번호의 라커를 전부 닫는다. 그 다음에는 번호가 3의 배수인 라커를 순서대로 찾아다니며 열려 있으면 닫고, 닫혀 있으면 연다. 그 다음에는 번호가 4의 배수인 라커를 순서대로 찾아다니며 열려있으면 닫고, 닫혀있으면 연다. 이후에 5의 배수, 6의 배수 .. 인 라커를 순서대로 찾아다니며 행동을 반복한다. 이런식으로 복도를 100번 지나가면 열린 라커의 문은 몇개가 되겠는가? . x = rep(FALSE, 100) . g &lt;- function(x,a){ n=length(x) x[(1:n) %% a == 0] &lt;- x[(1:n) %% a == 0] %&gt;% f x } . x=f(x) for (i in 2:100){ x=g(x,i) } . Warning message in 2:N: “수치형 표현식(numerical expression)은 100개의 구성요소들을 가지고 있기 때문에 오로지 첫번째 것만을 사용합니다.” . Error in a[n] &lt;- a[n - 1] * 0.5: replacement has length zero Traceback: 1. f(x) . x . [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [97] FALSE FALSE FALSE FALSE . sum(x) . [1] 0 . 8. &#47924;&#44417;&#54868; &#44867;&#51060; &#54588;&#50632;&#49845;&#45768;&#45796;. (25&#51216;) . 총 456명의 참가자가 &#39;무궁화 꽃이 피었습니다&#39; 게임에 참가한다. 기본적인 게임의 규칙은 아래와 같다. . 술래는 총 10회간 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39; 를 외친다. . | 참가자는 술래가 있는 곳 까지 이동해야 살 수 있다. . | 술래는 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39;를 외치다가 구호가 끝남과 동시에 뒤를 돌아본다. 이때 움직이는 사람은 죽는다 . | . 따라서 참가자는 술래가 벽을 보고 &#39;무궁화 꽃이 피었습니다&#39;를 외치는 동안만 이동할 수 있다. 욕심을 부려 더 이동하고자 하면 죽을 수 있다. 반대로 죽는 것을 지나치게 두려워한 나머지 매턴마다 조금씩만 이동한다면 10회의 제한횟수 내에 술래에게 도달하지 못하여 죽는다. . 게임환경과 관련된 세부적인 설정은 아래와 같다. . 술래와 참가자의 거리는 35이다. . | 술래는 처음 벽을 보고 $x$초간 무궁화 꽃이 피었습니다를 외친다. . | 모든 참가자는 1초에 거리1이상 움직일 수 없다고 가정한다. (예를들어 2.4초 동안은 최대 2.4의 거리를 이동할 수 있다. 반면 이동을 원치않으면 0의 거리만큼 움직이므로 0~2.4사이의 거리를 움직일 수 있다) . | . 술래와 참가자에 대한 설정값은 아래와 같다. . 술래에 대한 설정값 . 처음에는 술래가 10초간 무궁화 꽃이 피었습니다를 외친다. . | 그 다음에는 술래가 9.5초간 무궁화 꽃이 피었습니다를 외친다. . | 그 다음에도 0.5초씩 구호를 외치는 시간을 줄인다. 이것을 10회 반복한다. . | . 참가자에 대한 설정값 . 처음에는 참가자가 &quot;본인의번호/100&quot;을 계산하여 나온 숫자만큼 움직인다. 즉 10번 참가자는 0.1의 거리를 움직이고 456번 참가자는 4.56의 거리를 움직인다. . | 그 다음은 처음에 본인이 이동했던 거리에 1씩 더하여 움직인다. 즉 10번 참가자는 1.1의 거리를 움직이고 456번 참가자는 5.56의 거리를 움직인다. . | . - 예시1 . 300번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 3 | 4 | 5 | 6 | 7 | 7.5 | . 참가자의 총 이동거리 | 3 | 7 | 12 | 18 | 25 | 32.5 | . 생존할 수 없다. (6회에서 32.5까지 이동후 사망) . - 예시2 . 350번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 3.5 | 4.5 | 5.5 | 6.5 | 7.5 | 7.5 | . 참가자의 총 이동거리 | 3.5 | 8 | 13.5 | 20 | 27.5 | 35 | . 생존 할 수 있다. (6회에서 정확하게 7.5초간 이동하고 살아남는다) . - 예시3 . 400번 참가자의 경우 아래와 같이 이동하므로 . 1회 2회 3회 4회 5회 6회 . 술래의 외침시간 | 10 | 9.5 | 9.0 | 8.5 | 8.0 | 7.5 | . 참가자의 이동폭 | 4 | 5 | 6 | 7 | 8 | 5 | . 참가자의 총 이동거리 | 4 | 9 | 15 | 22 | 30 | 35 | . 생존 할 수 있다. (6회에서 5초간만 이동하면 35만큼 이동하므로 살아남는다) . (a) 1&#48264;, 67&#48264;, 218&#48264;, 456&#48264; &#52280;&#44032;&#51088;&#51032; &#49373;&#51316;&#50668;&#48512;&#47484; &#54869;&#51064;&#54616;&#45716; &#54632;&#49688;&#47484; &#51089;&#49457;&#54616;&#46972;. . 술래 . t = c(seq(10,by=-0.5,length.out=10)) t . [1] 10.0 9.5 9.0 8.5 8.0 7.5 7.0 6.5 6.0 5.5 . 참가자 . $x= frac{n}{100}+ frac{n}{100}+1+ frac{n}{100}+2+ dots+ frac{n}{100}+9 $ . 참가자가 생존하기 위해서는 1) 술래의 외침시간 &lt; 이동폭 2) 10회 동안 이동거리 &gt;= 35 . num=350 steps = num/100 + 0:9 steps . [1] 3.5 4.5 5.5 6.5 7.5 8.5 9.5 10.5 11.5 12.5 . t &gt;= steps . [1] TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE . sum(steps[t&gt;=steps]) . [1] 27.5 . t[t&lt;steps][1] . [1] 7.5 . sum(steps[t&gt;=steps]) + t[t&lt;steps][1] &gt;= 35 . [1] TRUE . t = c(seq(10,by=-0.5,length.out=10)) surv &lt;- c() num = 67 steps = num/100 + 0:9 x1 &lt;- sum(steps[t&gt;=steps]) + t[t&lt;steps][1] &gt;= 35 num = 218 steps = num/100 + 0:9 x2 &lt;- sum(steps[t&gt;=steps]) + t[t&lt;steps][1] &gt;= 35 num = 456 steps = num/100 + 0:9 x3 &lt;- sum(steps[t&gt;=steps]) + t[t&lt;steps][1] &gt;= 35 surv &lt;- c(x1, x2, x3) surv . [1] FALSE TRUE FALSE . (b) &#51204;&#52404; &#49373;&#51316;&#51088;&#51473; &#47751;&#47749;&#51060; &#49332;&#50500;&#45224;&#45716;&#51648; &#44228;&#49328;&#54616;&#46972;. . t = c(seq(10,by=-0.5,length.out=10)) surv &lt;- c() for (num in 1:456){ steps = num/100 + 0:9 surv[num] &lt;- sum(steps[t&gt;=steps]) + t[t&lt;steps][1] &gt;= 35 } sum(surv) . [1] 85 . 9. &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#49884;&#44033;&#54868; &#54616;&#46972;. (15&#51216;) . 다음은 인터넷에서 어떠한 자료를 다운받아 매트릭스로 저장하는 코드이다. . df=read.csv(&quot;https://raw.githubusercontent.com/guebin/2021IR/master/_notebooks/round2.csv&quot;) mat=as.matrix(df) . 매트릭스는 mat이라는 변수에 저장되어 있다. . (a) mat&#51032; &#52395;&#48264;&#51704; &#50676;&#51012; $x$, &#46160;&#48264;&#51704;&#50676;&#51012; $y$&#47196; &#49373;&#44033;&#54616;&#44256; plot&#54632;&#49688;&#47484; &#53685;&#54616;&#50668; &#50500;&#47000;&#50752; &#44057;&#51008; &#49328;&#51216;&#46020;&#47484; &#44536;&#47140;&#46972;. . . df=read.csv(&quot;https://raw.githubusercontent.com/guebin/2021IR/master/_notebooks/round2.csv&quot;) mat=as.matrix(df) . plot(mat[,1],mat[,2]) . (b) &#47588;&#53944;&#47533;&#49828;&#51032; &#52395;&#48264;&#51704; &#54665;(first row)&#47484; &#52636;&#47141;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. . - 힌트: 출력결과는 (12,313)이 나와야 한다. . X &lt;- mat[1,] X . x y 12 313 . (c) (b)&#51032; &#44208;&#44284;&#50640; &#50500;&#47000;&#51032; &#50672;&#49328;&#51012; &#49688;&#54665;&#54616;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. . $$ begin{bmatrix} 0 &amp; -1 -1 &amp; 0 end{bmatrix} begin{bmatrix} 12 313 end{bmatrix} $$ Y = rbind(c(0,-1),c(-1,0)) Y . [,1] [,2] [1,] 0 -1 [2,] -1 0 . Y %*% X . [,1] [1,] -313 [2,] -12 . f = function(X){ dim(X)=c(2,1) X } . rbind(c(0,-1),c(-1,0)) %*% f(mat[1,]) . [,1] [1,] -313 [2,] -12 . (d) (b)-(c) &#44284;&#51221;&#51012; mat&#51032; &#47784;&#46321;&#54665;&#50640; &#48152;&#48373;&#54616;&#50668; &#49352;&#47196;&#50868; &#47588;&#53944;&#47533;&#49828;&#47484; &#47564;&#46308;&#50612;&#46972;. . - 힌트: 아래의 과정을 따른다. . (i) mat와 동일한 dim을 가진 mat2를 만든다. | (ii) mat의 첫번째 행에 (b)-(c)의 과정을 적용하여 길이가 2인 벡터를 얻는다. | (iii) (ii)의 과정에서 얻은 벡터를 새로운 매트릭스의 첫번째 행에 넣는다. | (iv) mat의 두번째 행에 대하여 (ii)-(iii)의 과정을 반복한다. 이후 세번째, 네번째 행에 대하여 (ii)-(iii)의 과정을 반복한다. | . g = function(X){ dim(X)=c(1,2) X } . mat2 = mat dim(mat2) . [1] 5513 2 . mat2 = mat*0 for (i in 1:5513) mat2[i,] = rbind(c(0,-1),c(-1,0)) %*% f(mat[i,]) %&gt;% g . (e) (d)&#51032; &#44208;&#44284;&#47196; &#49373;&#49457;&#46104; &#47588;&#53944;&#47533;&#49828;&#51032; &#52395;&#48264;&#51704; &#50676;&#51012; x, &#46160;&#48264;&#51704; &#50676;&#51012; y&#47196; &#54616;&#44256; &#49328;&#51216;&#46020;&#47484; &#44536;&#47140;&#46972;. (&#51216;&#51032; &#49353;&#51008; &#48521;&#51008;&#49353;&#51004;&#47196; &#54616;&#46972;) . - 힌트: 아래와 같은 그림이 나와야 한다. . . plot(mat2[,1],mat2[,2], col=&#39;red&#39;) .",
            "url": "https://sempre39.github.io/econ_blog/2022/01/21/_11_09_2021%EB%85%84_1%ED%95%99%EA%B8%B0_R%EC%9E%85%EB%AC%B8%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC.html",
            "relUrl": "/2022/01/21/_11_09_2021%EB%85%84_1%ED%95%99%EA%B8%B0_R%EC%9E%85%EB%AC%B8%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC.html",
            "date": " • Jan 21, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "(A3) 중간고사 대비문제",
            "content": "#. R&#51012; &#51060;&#50857;&#54616;&#50668; &#45796;&#51020;&#51012; &#44228;&#49328;&#54616;&#50668;&#46972;. . $2^{-5}+2^{3}$ | . 2^(-5) + 2^3 . [1] 8.03125 . $ sqrt{33}$ | . sqrt(33) . [1] 5.744563 . $ sum_{k=1}^{100} frac{1}{k^2+2k+1}$ㅁㅁ | . k = c(1:100) . k . [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [19] 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 [55] 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 [73] 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 [91] 91 92 93 94 95 96 97 98 99 100 . sum(1/(k^2+2*k+1)) . [1] 0.6350819 . ... | . #. &#50500;&#47000;&#50752; &#44057;&#51008; &#49688;&#50676;&#51012; &#47564;&#46308;&#50612;&#46972;. . $(1,3,5,...,101)$ | . seq(1,101,2) . [1] 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 [20] 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 [39] 77 79 81 83 85 87 89 91 93 95 97 99 101 . ... | . #. &#50500;&#47000;&#50752; &#44057;&#51008; &#54632;&#49688;&#47484; &#49440;&#50616;&#54616;&#46972;. $x=1,2,3$ &#50640; &#45824;&#54616;&#50668; &#51452;&#50612;&#51652; &#54632;&#49688;&#51032; &#44208;&#44284;&#44050;&#51012; &#52636;&#47141;&#54616;&#46972;. . $f(x)=x^2$ | . f &lt;- function(x){ x^2 } . x = c(1:3) . f(x) . [1] 1 4 9 . #. &#50500;&#47000;&#51473; &#50739;&#51008;&#44163;&#51008;? . (a) $e^x= sum_{n=0}^{ infty} frac{x^n}{n!}$ . (b) $e^x= 1+x+x^2+x^3+ dots $ . (c) $e^x= 1-(x-1)+(x-1)^2-(x-1)^3+ dots $ . (풀이) . f&lt;-function(x,N){ a&lt;-c() a[1]=x for(n in 2:N) a[n]=a[n-1]*x/n sum(a)+1 } . g&lt;-function(x,N){ a&lt;-c() a[1]=x for(n in 2:N) a[n]=a[n-1]*x sum(a)+1 } . h&lt;-function(x,N){ a&lt;-c() a[1]= -(x-1) for(n in 2:N) a[n]=a[n-1]*(1-x) sum(a)+1 } . x=2 for (k in 5:20) print(c(exp(x)-f(x,k) , exp(x)-g(x,k), exp(x)-h(x,k))) . [1] 0.1223894 -55.6109439 7.3890561 [1] 0.03350054 -119.61094390 6.38905610 [1] 8.103718e-03 -2.476109e+02 7.389056e+00 [1] 1.754512e-03 -5.036109e+02 6.389056e+00 [1] 3.435769e-04 -1.015611e+03 7.389056e+00 [1] 6.138994e-05 -2.039611e+03 6.389056e+00 [1] 1.008322e-05 -4.087611e+03 7.389056e+00 [1] 1.532098e-06 -8.183611e+03 6.389056e+00 [1] 2.165414e-07 -1.637561e+04 7.389056e+00 [1] 2.860474e-08 -3.275961e+04 6.389056e+00 [1] 3.546512e-09 -6.552761e+04 7.389056e+00 [1] 4.142349e-10 -1.310636e+05 6.389056e+00 [1] 4.573142e-11 -2.621356e+05 7.389056e+00 [1] 4.786394e-12 -5.242796e+05 6.389056e+00 [1] 4.760636e-13 -1.048568e+06 7.389056e+00 [1] 4.529710e-14 -2.097144e+06 6.389056e+00 . $x=2$일때: $k$가 커질수록 $exp(x) approx f(x,k)$ 이지만 다른것은 그렇지 않음 | . x=3 for (k in 5:20) print(c(exp(x)-f(x,k) , exp(x)-g(x,k), exp(x)-h(x,k))) . [1] 1.685537 -343.914463 41.085537 [1] 0.6730369 -1072.9144631 -22.9144631 [1] 0.2391084 -3259.9144631 105.0855369 [1] 7.638514e-02 -9.820914e+03 -1.509145e+02 [1] 2.214407e-02 -2.950391e+04 3.610855e+02 [1] 5.871745e-03 -8.855291e+04 -6.629145e+02 [1] 1.433839e-03 -2.656999e+05 1.385086e+03 [1] 3.243623e-04 -7.971409e+05 -2.710914e+03 [1] 6.832928e-05 -2.391464e+06 5.481086e+03 [1] 1.346506e-05 -7.174433e+06 -1.090291e+04 [1] 2.492217e-06 -2.152334e+07 2.186509e+04 [1] 4.348086e-07 -6.457006e+07 -4.367091e+04 [1] 7.173653e-08 -1.937102e+08 8.740109e+04 [1] 1.122453e-08 -5.811307e+08 -1.747429e+05 [1] 1.669996e-09 -1.743392e+09 3.495451e+05 [1] 2.368168e-10 -5.230177e+09 -6.990309e+05 . x=10 for (k in 5:50) print(c(exp(x)-f(x,k) , exp(x)-g(x,k), exp(x)-h(x,k))) . [1] 20548.80 -89084.53 75170.47 [1] 19159.91 -1089084.53 -456270.53 [1] 17175.78 -11089084.53 4326698.47 [1] 14695.62 -111089084.53 -38720022.53 [1] 1.193989e+04 -1.111089e+09 3.487005e+08 [1] 9.184161e+03 -1.111109e+10 -3.138084e+09 [1] 6.678950e+03 -1.111111e+11 2.824298e+10 [1] 4.591274e+03 -1.111111e+12 -2.541866e+11 [1] 2.985370e+03 -1.111111e+13 2.287679e+12 [1] 1.838295e+03 -1.111111e+14 -2.058911e+13 [1] 1.073579e+03 -1.111111e+15 1.853020e+14 [1] 5.956311e+02 -1.111111e+16 -1.667718e+15 [1] 3.144854e+02 -1.111111e+17 1.500946e+16 [1] 1.582933e+02 -1.111111e+18 -1.350852e+17 [1] 7.608695e+01 -1.111111e+19 1.215767e+18 [1] 3.498377e+01 -1.111111e+20 -1.094190e+19 [1] 1.541083e+01 -1.111111e+21 9.847709e+19 [1] 6.514037e+00 -1.111111e+22 -8.862938e+20 [1] 2.645867e+00 -1.111111e+23 7.976644e+21 [1] 1.034129e+00 -1.111111e+24 -7.178980e+22 [1] 3.894339e-01 -1.111111e+25 6.461082e+23 [1] 1.414743e-01 -1.111111e+26 -5.814974e+24 [1] 4.963739e-02 -1.111111e+27 5.233476e+25 [1] 1.683850e-02 -1.111111e+28 -4.710129e+26 [1] 5.528535e-03 -1.111111e+29 4.239116e+27 [1] 1.758548e-03 -1.111111e+30 -3.815204e+28 [1] 5.424228e-04 -1.111111e+31 3.433684e+29 [1] 1.623837e-04 -1.111111e+32 -3.090315e+30 [1] 4.722033e-05 -1.111111e+33 2.781284e+31 [1] 1.334876e-05 -1.111111e+34 -2.503156e+32 [1] 3.671161e-06 -1.111111e+35 2.252840e+33 [1] 9.829419e-07 -1.111111e+36 -2.027556e+34 [1] 2.563938e-07 -1.111111e+37 1.824800e+35 [1] 6.519986e-08 -1.111111e+38 -1.642320e+36 [1] 1.617445e-08 -1.111111e+39 1.478088e+37 [1] 3.918103e-09 -1.111111e+40 -1.330279e+38 [1] 9.276846e-10 -1.111111e+41 1.197252e+39 [1] 2.182787e-10 -1.111111e+42 -1.077526e+40 [1] 5.093170e-11 -1.111111e+43 9.697737e+40 [1] 1.455192e-11 -1.111111e+44 -8.727964e+41 [1] 3.637979e-12 -1.111111e+45 7.855167e+42 [1] 3.637979e-12 -1.111111e+46 -7.069650e+43 [1] 3.637979e-12 -1.111111e+47 6.362685e+44 [1] 3.637979e-12 -1.111111e+48 -5.726417e+45 [1] 3.637979e-12 -1.111111e+49 5.153775e+46 [1] 3.637979e-12 -1.111111e+50 -4.638398e+47 . 답: (a) . #. &#45796;&#51020;&#51012; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. . 다음은 어느 회사의 연봉에 대한 규정이다. . (가) 입사 첫째 해 연봉은 $a$원이고, 입사 19년째 해까지의 연봉은 해마다 직전 연봉에서 8%씩 인상된다. . (나) 입사 20년째 해부터의 연봉은 입사 19년째 해 연봉의 2/3로 한다. . 이 회사에 입사한 사람이 28년동안 근무하여 받는 연봉의 총합은? . sal&lt;-c() sal[1]&lt;-1 . for(i in 2:19){ sal[i] = sal[i-1]*1.08 } . sal . [1] 1.000000 1.080000 1.166400 1.259712 1.360489 1.469328 1.586874 1.713824 [9] 1.850930 1.999005 2.158925 2.331639 2.518170 2.719624 2.937194 3.172169 [17] 3.425943 3.700018 3.996019 . for(i in 20:28){ sal[i] = sal[19]*2/3 } . sal . [1] 1.000000 1.080000 1.166400 1.259712 1.360489 1.469328 1.586874 1.713824 [9] 1.850930 1.999005 2.158925 2.331639 2.518170 2.719624 2.937194 3.172169 [17] 3.425943 3.700018 3.996019 2.664013 2.664013 2.664013 2.664013 2.664013 [25] 2.664013 2.664013 2.664013 2.664013 . sum(sal) . [1] 65.42238 . #. &#45796;&#51020; &#47928;&#51109;&#51012; &#51069;&#44256; &#52280;&#44144;&#51667;&#51012; &#54032;&#45800;&#54616;&#49884;&#50724;. . _a는 변수이름으로 가능하다. | . _a &lt;- 1 . Error in parse(text = x, srcfile = src): &lt;text&gt;:1:1: 예상하지 못한 입력입니다. 1: _ ^ Traceback: . ... | . # &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#49884;&#44033;&#54868; &#54616;&#46972;. . 두점 $(1,2)$, $(1.1,2.1)$를 붉은 점으로 각각 시각화 하라. . | 동일한 플랏에 $(-1,-2)$, $(-1.1,-2.1)$을 푸른점으로 각각 시각화 하라. . | . 출력예시 . # &#48380;&#47553;&#44277;&#51032; &#49440;&#53469; . A,B 두 사람이 볼링을 치고 있습니다. 두 사람은 서로 무게가 다른 볼링공을 고르려고 합니다. 볼링공은 총 N개가 있으며 각 볼링공마다 무게가 적혀 있고, 공의 번호는 1번부터 순서대로 부여됩니다. 또한 같은 무게의 공이 여러개 있을 수 있지만, 서로 다른 공으로 간주합니다. 볼링공의 무게는 1부터 M까지의 자연수 형태로 존재합니다. 예를들어 N이 5이고, M이 3이며 각각의 무게가 차례대로 1,3,2,3,2일 때 각 공의 번호가 차례대로 1번부터 5번까지 부여됩니다. 이때 두 사람이 고를 수 있는 볼링공 번호의 조합을 구하면 다음과 같습니다. . (1번,2번), (1번,3번), (1번,4번), (1번,5번), (2번,3번), (2번,5번), (3번,4번), (4번,5번) . 결과적으로 두 사람이 공을 고르는 경우의 수는 8가지입니다. N개의 공의 무게가 각각 주어질 때, 두 사람이 볼링공을 고르는 경우의 수를 구하는 프로그램을 작성하세요. . - 입력예시 . 입력 5 3 1 3 2 3 2 출력 8 . a=c(1,3,2,3,2) A=rep(0,25*2) dim(A)=c(25,2) A . [,1] [,2] [1,] 0 0 [2,] 0 0 [3,] 0 0 [4,] 0 0 [5,] 0 0 [6,] 0 0 [7,] 0 0 [8,] 0 0 [9,] 0 0 [10,] 0 0 [11,] 0 0 [12,] 0 0 [13,] 0 0 [14,] 0 0 [15,] 0 0 [16,] 0 0 [17,] 0 0 [18,] 0 0 [19,] 0 0 [20,] 0 0 [21,] 0 0 [22,] 0 0 [23,] 0 0 [24,] 0 0 [25,] 0 0 . k=1 for (i in 1:5){ for (j in 1:5){ A[k,]&lt;-c(a[i],a[j]) k=k+1 } } . A . [,1] [,2] [1,] 1 1 [2,] 1 3 [3,] 1 2 [4,] 1 3 [5,] 1 2 [6,] 3 1 [7,] 3 3 [8,] 3 2 [9,] 3 3 [10,] 3 2 [11,] 2 1 [12,] 2 3 [13,] 2 2 [14,] 2 3 [15,] 2 2 [16,] 3 1 [17,] 3 3 [18,] 3 2 [19,] 3 3 [20,] 3 2 [21,] 2 1 [22,] 2 3 [23,] 2 2 [24,] 2 3 [25,] 2 2 . vec1&lt;-c() vec2&lt;-c() for(i in 1:25){ vec1[i] &lt;- A[i,1] != A[i,2] vec2[i] &lt;- A[i,1] &gt; A[i,2] } . vec1 . [1] FALSE TRUE TRUE TRUE TRUE TRUE FALSE TRUE FALSE TRUE TRUE TRUE [13] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE TRUE TRUE FALSE TRUE [25] FALSE . vec2 . [1] FALSE FALSE FALSE FALSE FALSE TRUE FALSE TRUE FALSE TRUE TRUE FALSE [13] FALSE FALSE FALSE TRUE FALSE TRUE FALSE TRUE TRUE FALSE FALSE FALSE [25] FALSE . sum(vec1 &amp; vec2) . [1] 8 .",
            "url": "https://sempre39.github.io/econ_blog/2022/01/21/_11_02_(A3)_%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC_%EB%8C%80%EB%B9%84%EB%AC%B8%EC%A0%9C.html",
            "relUrl": "/2022/01/21/_11_02_(A3)_%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC_%EB%8C%80%EB%B9%84%EB%AC%B8%EC%A0%9C.html",
            "date": " • Jan 21, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://sempre39.github.io/econ_blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://sempre39.github.io/econ_blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "",
          "url": "https://sempre39.github.io/econ_blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://sempre39.github.io/econ_blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}